"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["65446"],{98470:function(e,n,t){t.r(n),t.d(n,{metadata:()=>s,default:()=>d,frontMatter:()=>o,contentTitle:()=>r,toc:()=>h,assets:()=>c});var s=JSON.parse('{"id":"phaser/concepts/scenes/cross-scene-communication","title":"Cross Scene Communication","description":"Phaser Cross Scene Communication","source":"@site/docs/phaser/concepts/scenes/cross-scene-communication.md","sourceDirName":"phaser/concepts/scenes","slug":"/phaser/concepts/scenes/cross-scene-communication","permalink":"/phaser/concepts/scenes/cross-scene-communication","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"visibility":"public","slug":"cross-scene-communication","title":"Cross Scene Communication","description":"Phaser Cross Scene Communication","seoTitle":"Cross Scene Communication","seoDescription":"Phaser Cross Scene Communication"},"sidebar":"PhaserSidebar","previous":{"title":"Scenes","permalink":"/phaser/concepts/scenes"},"next":{"title":"Textures","permalink":"/phaser/concepts/textures"}}'),i=t(74848),a=t(28453);let o={visibility:"public",slug:"cross-scene-communication",title:"Cross Scene Communication",description:"Phaser Cross Scene Communication",seoTitle:"Cross Scene Communication",seoDescription:"Phaser Cross Scene Communication"},r,c={},h=[{value:"Calling a Scene Function",id:"calling-a-scene-function",level:3},{value:"Listening for Scene Events",id:"listening-for-scene-events",level:3},{value:"Exchange Data via the Game Registry",id:"exchange-data-via-the-game-registry",level:3},{value:"Scene Updating and Rendering",id:"scene-updating-and-rendering",level:2},{value:"Scene List",id:"scene-list",level:3},{value:"Scene List Input",id:"scene-list-input",level:3},{value:"Controlling Scene Order",id:"controlling-scene-order",level:2},{value:"Moving Scenes",id:"moving-scenes",level:3},{value:"Scene Ordering Demo",id:"scene-ordering-demo",level:3},{value:"Spawning Multiple Scenes",id:"spawning-multiple-scenes",level:2},{value:"Scene Rendering",id:"scene-rendering",level:3},{value:"Multi Scene Demo",id:"multi-scene-demo",level:3},{value:"How the Scene dragging is done",id:"how-the-scene-dragging-is-done",level:3}];function l(e){let n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Now we know how to create and configure Scenes, let's get them talking to each other. There are several ways to achieve this: Calling a function directly, listening for an event or exchanging data via the registry. We'll cover each now:"}),"\n",(0,i.jsx)(n.h3,{id:"calling-a-scene-function",children:"Calling a Scene Function"}),"\n",(0,i.jsx)(n.p,{children:"First we'll create two basic Scenes:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneA extends Phaser.Scene {\n\n    constructor ()\n    {\n        super('MyFirstScene');\n    }\n\n    preload ()\n    {\n        this.load.image('asuna', 'assets/sprites/asuna_by_vali233.png');\n    }\n\n    create ()\n    {\n        this.input.on('pointerup', this.clickHandler, this);\n\n        this.add.text(10, 10, 'Click to get image', { font: '16px Courier', fill: '#00ff00' }).setDepth(1000);\n    }\n\n    clickHandler ()\n    {\n        let sceneB = this.scene.get('MySecondScene');\n\n        let position = sceneB.getPosition();\n\n        this.add.image(position.x, position.y, 'asuna');\n    }\n\n}\n\nclass SceneB extends Phaser.Scene {\n\n    constructor ()\n    {\n        super('MySecondScene');\n    }\n\n    getPosition ()\n    {\n        let x = Phaser.Math.Between(0, 800);\n        let y = Phaser.Math.Between(0, 600);\n\n        return new Phaser.Math.Vector2(x, y);\n    }\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here ",(0,i.jsx)(n.code,{children:"SceneA"})," listens out for pointer events. When it receives one it calls the ",(0,i.jsx)(n.code,{children:"clickHandler"})," method. In here we grab a reference to SceneB. This is done using the Scenes key, which is ",(0,i.jsx)(n.code,{children:"MySecondScene"}),". Once we have that, we can call any public methods which it exposes. In this case we're calling ",(0,i.jsx)(n.code,{children:"getPosition"}),". This method returns a vec2 with a random location in it. We then add an image at that location."]}),"\n",(0,i.jsx)(n.p,{children:"It's not exactly a complex example, but you should get the idea: Any public function defined on a Scene can be called by any other scene."}),"\n",(0,i.jsx)(n.h3,{id:"listening-for-scene-events",children:"Listening for Scene Events"}),"\n",(0,i.jsx)(n.p,{children:"In this example instead of calling a function on SceneB directly, we're going to have it listen for events from SceneA. The set-up is the same as before, but our clickHandler is different:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneA extends Phaser.Scene {\n\n    constructor ()\n    {\n        super('GameScene');\n    }\n\n    preload ()\n    {\n        this.load.image('bg', 'assets/skies/sky4.png');\n        this.load.image('crate', 'assets/sprites/crate.png');\n    }\n\n    create ()\n    {\n        this.add.image(400, 300, 'bg');\n\n        for (let i = 0; i < 64; i++)\n        {\n            let x = Phaser.Math.Between(0, 800);\n            let y = Phaser.Math.Between(0, 600);\n\n            this.add.image(x, y, 'crate').setInteractive();\n        }\n\n        this.input.on('gameobjectup', this.clickHandler, this);\n    }\n\n    clickHandler (pointer, box)\n    {\n        //  Disable our box\n        box.input.enabled = false;\n        box.setVisible(false);\n\n        //  Dispatch a Scene event\n        this.events.emit('addScore');\n    }\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, when a box is clicked, we dispatch the ",(0,i.jsx)(n.code,{children:"addScore"})," event. Our SceneB looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneB extends Phaser.Scene {\n\n    constructor ()\n    {\n        super({ key: 'UIScene', active: true });\n\n        this.score = 0;\n    }\n\n    create ()\n    {\n        //  Our Text object to display the Score\n        let info = this.add.text(10, 10, 'Score: 0', { font: '48px Arial', fill: '#000000' });\n\n        //  Grab a reference to the Game Scene\n        let ourGame = this.scene.get('GameScene');\n\n        //  Listen for events from it\n        ourGame.events.on('addScore', function () {\n\n            this.score += 10;\n\n            info.setText('Score: ' + this.score);\n\n        }, this);\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It creates a text object to display the score, gets a reference to SceneA and then listens for ",(0,i.jsx)(n.code,{children:"addScore"})," events from it. When it receives one it updates the local score and Text object."]}),"\n",(0,i.jsx)(n.p,{children:"The advantage to this approach is that SceneA is not tightly coupled to your SceneB. As long as the event names don't change, SceneA can happily sit there, dispatching events as long as it likes, knowing that any other Scenes interested in them will pick them up. However, it does mean that SceneB is coupled to SceneA, as it needs a reference to it in order to listen to its event emitter. We can avoid this entirely by using the Game Registry."}),"\n",(0,i.jsx)(n.h3,{id:"exchange-data-via-the-game-registry",children:"Exchange Data via the Game Registry"}),"\n",(0,i.jsx)(n.p,{children:"We're going to expand upon the previous example slightly. This time we will be using the Game Registry, which is an instance of the Data Manager Plugin, in order to exchange data. This is SceneA, our GameScene. It's the same as before, except we tint every other box red. If you click a red box then you lose one of your lives. If you click a normal box, you gain a point:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneA extends Phaser.Scene {\n\n    constructor ()\n    {\n        super('GameScene');\n\n        this.score = 0;\n        this.lives = 6;\n    }\n\n    preload ()\n    {\n        this.load.image('bg', 'assets/skies/sky4.png');\n        this.load.image('crate', 'assets/sprites/crate.png');\n    }\n\n    create ()\n    {\n        //  Store the score and lives in the Game Registry\n        this.registry.set('score', this.score);\n        this.registry.set('lives', this.lives);\n\n        this.add.image(400, 300, 'bg');\n\n        for (let i = 0; i < 64; i++)\n        {\n            let x = Phaser.Math.Between(0, 800);\n            let y = Phaser.Math.Between(0, 600);\n\n            let box = this.add.image(x, y, 'crate').setInteractive();\n\n            if (i % 2)\n            {\n                box.setTint(0xff0000);\n            }\n        }\n\n        this.input.on('gameobjectup', this.clickHandler, this);\n    }\n\n    clickHandler (pointer, box)\n    {\n        if (this.lives === 0)\n        {\n            return;\n        }\n\n        //  Disable our box\n        box.input.enabled = false;\n        box.setVisible(false);\n\n        //  If the box was tinted red, you lose a life\n        if (box.tintTopLeft === 255)\n        {\n            this.lives--;\n            this.registry.set('lives', this.lives);\n        }\n        else\n        {\n            this.score++;\n            this.registry.set('score', this.score);\n        }\n    }\n\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As the boxes are clicked we updated the respective values in the registry using the ",(0,i.jsx)(n.code,{children:"registry.set"})," call."]}),"\n",(0,i.jsx)(n.p,{children:"Now to SceneB. This Scene is the same as before, except we've added another Text object to display the lives remaining:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneB extends Phaser.Scene {\n\n    constructor ()\n    {\n        super({ key: 'UIScene', active: true });\n\n        this.scoreText;\n        this.livesText;\n    }\n\n    create ()\n    {\n        //  Our Text object to display the Score\n        this.scoreText = this.add.text(10, 10, 'Score: 0', { font: '32px Arial', fill: '#000000' });\n        this.livesText = this.add.text(10, 48, 'Lives: 6', { font: '32px Arial', fill: '#000000' });\n\n        //  Check the Registry and hit our callback every time the 'score' value is updated\n        this.registry.events.on('changedata', this.updateData, this);\n    }\n\n    updateData (parent, key, data)\n    {\n        if (key === 'score')\n        {\n            this.scoreText.setText('Score: ' + data);\n        }\n        else if (key === 'lives')\n        {\n            this.livesText.setText('Lives: ' + data);\n        }\n    }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["It listens out for a ",(0,i.jsx)(n.code,{children:"changedata"})," event from the Registry and invokes the ",(0,i.jsx)(n.code,{children:"updateData"})," method if it receives one. This method is set 3 items: the parent, i.e. the owner of the Data Manager, which in this case is the Game. It then receives the string-based key of the entry that was changed, and then finally the new value of this entry."]}),"\n",(0,i.jsx)(n.p,{children:"By checking the key we can tell if it was the score or the lives that were changed and update our text objects respectively."}),"\n",(0,i.jsx)(n.p,{children:"As you can see, using the Game Registry gives us a fully decoupled method of communication between multiple Scenes."}),"\n",(0,i.jsx)(n.h2,{id:"scene-updating-and-rendering",children:"Scene Updating and Rendering"}),"\n",(0,i.jsx)(n.p,{children:"We mentioned that the Game owns the truly global classes - two of these are the renderer and the Scene Manager. When the game steps, usually as a result of a Request Animation Frame update in the browser, it will tell the Scene Manager to update. The Scene Manager is responsible for looking after all Scenes in your game. It can add new ones, start and stop them and also takes direction from the game as to when to update them."}),"\n",(0,i.jsx)(n.p,{children:"Scenes are stored in the Scene Manager in a list. The order of the Scenes in this list control two important factors. The first is that it controls the order in which Scenes are rendered. The second is that it controls the order in which Scenes are updated."}),"\n",(0,i.jsxs)(n.p,{children:["Each game step the Scene Manager will iterate through all of its Scenes in ",(0,i.jsx)(n.em,{children:"reverse"})," order, updating each one of them in turn. It first checks to see if the Scene is active (i.e. hasn't been sent to sleep or shut down) and then tells the Scene Systems to update. This in turn tells all Scene plugins to update, which tells all Game Objects to update, and so on. Essentially, everything your Scene does that isn't related to rendering happens at this point."]}),"\n",(0,i.jsx)(n.p,{children:"Once the update loop has completed, the Scene Manager then iterates through all Scenes, from back to front, rendering each one. It does this by passing a reference to the Renderer to each Scene, which in turn hands it to the Scene Camera Manager to deal with. The Camera Manager takes the renderer and constructs the visual display of the Scene upon it, factoring in multiple cameras, everything they can see and any special effects running on them."}),"\n",(0,i.jsx)(n.h3,{id:"scene-list",children:"Scene List"}),"\n",(0,i.jsxs)(n.p,{children:["The drawing order is important. If you add three Scenes to the Scene Manager, it will draw them in the order in which they were ",(0,i.jsx)(n.em,{children:"added"}),", from back to front, meaning the first Scene added would be at the very back of the display, and the most recent Scene added would draw over the top of it, at the front. It works like a standard display list and can be controlled as such, which we'll cover in the next section. Here's a simplified example showing the effect of adding multiple Scenes."]}),"\n",(0,i.jsx)(n.p,{children:"Here's our first Scene. All it does is draw a rectangle with a letter on it, but it's enough to demonstrate what is going on:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneA extends Phaser.Scene {\n\n    constructor ()\n    {\n        super({ key: 'SceneA', active: true });\n    }\n\n    create ()\n    {\n        let graphics = this.add.graphics();\n\n        graphics.fillStyle(0xff3300, 1);\n\n        graphics.fillRect(100, 200, 600, 300);\n        graphics.fillRect(100, 100, 100, 100);\n\n        this.add.text(120, 110, 'A', { font: '96px Courier', fill: '#000000' });\n    }\n}\n\nlet config = {\n    type: Phaser.AUTO,\n    width: 800,\n    height: 600,\n    backgroundColor: '#392542',\n    parent: 'phaser-example',\n    scene: [ SceneA ]\n};\n\nlet game = new Phaser.Game(config);\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you run the code as-is you'll see this:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"Now, let's add another Scene. It's going to do the same again but with a different color:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class SceneB extends Phaser.Scene {\n\n    constructor ()\n    {\n        super({ key: 'SceneB', active: true });\n    }\n\n    create ()\n    {\n        let graphics = this.add.graphics();\n\n        graphics.fillStyle(0xff9933, 1);\n\n        graphics.fillRect(100, 200, 600, 300);\n        graphics.fillRect(200, 100, 100, 100);\n\n        this.add.text(220, 110, 'B', { font: '96px Courier', fill: '#000000' });\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"We need to update the scene array in the Game Config to add in this new Scene:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"scene: [ SceneA, SceneB ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"and the result is, as you'd expect, this:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"Scene B appears over the top of Scene A because it has been added second in the Scene array passed in the Game Config. If you were to swap the order in this array, Scene A would appear on the top."}),"\n",(0,i.jsx)(n.p,{children:"We'll add one final Scene just to complete the effect. Scene C is exactly the same as before. Our final order looks like this:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"Because we used this array in the Game Config:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"scene: [ SceneA, SceneB, SceneC ]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Swap any of those elements around and you'll impact the order in which they are rendered and updated. Of course, you're not limited to just the order in which you specify the Scenes in your config. You can manipulate them using the ScenePlugin, which we'll demonstrate fully in a moment."}),"\n",(0,i.jsx)(n.h3,{id:"scene-list-input",children:"Scene List Input"}),"\n",(0,i.jsxs)(n.p,{children:["You may wonder why the Scene Manager iterates through the Scenes in reverse order when updating them. The reason is to do with Input. If you look at the image above you can see that our UI Scene is the top-most Scene in the display, because naturally we'd want the UI to sit over the top of the game itself. But imagine you have an interactive object in your game, such as a clickable area, and the UI overlaps with it. You'd nearly always want the UI to receive the input event, not the interactive object it is overlapping. This is why we iterate in reverse, so the Input Plugin has a chance to process the top-most items on the display list ",(0,i.jsx)(n.em,{children:"and"})," the top-most Scenes on the scene list first."]}),"\n",(0,i.jsxs)(n.p,{children:["By default, if a Scene at the top of the scene list receives ",(0,i.jsx)(n.em,{children:"and handles"})," a valid input request, then all of the Scenes below that one will just skip their input processing in order to save time. You can change this behavior by calling ",(0,i.jsx)(n.code,{children:"this.input.setGlobalTopOnly(false)"})," from any Scene. Every Scene will then process input, regardless of its position in the scene list."]}),"\n",(0,i.jsx)(n.p,{children:"By iterating in this order we're also able to have a UI Scene control the game scene immediately. For example, you could have a Pause icon, and clicking it would have a chance to tell the game to pause straight away, without having to wait for the next frame first. It just makes your game feel more responsive."}),"\n",(0,i.jsx)(n.h2,{id:"controlling-scene-order",children:"Controlling Scene Order"}),"\n",(0,i.jsx)(n.p,{children:"The Scene Plugin has a selection of methods that allow you to precisely control the order of the Scenes in the scene list. This is crucial because their position in the list dictates the order in which they are drawn. It's not always possible to know in advance the order of your scenes when creating them, or which scenes are going to be running at the same time, so it's vital you can easily control their order."}),"\n",(0,i.jsx)(n.p,{children:"It's worth stating that all interactions with Scenes should be done via the Scene Plugin. Every Scene owns an instance of this core plugin and it acts as an interface to the Scene Manager. You should rarely, if ever, access the Scene Manager directly. If you find yourself calling methods on the Scene Manager then change your code, because it likely has structural problems that will grow over time."}),"\n",(0,i.jsxs)(n.p,{children:["In short, use ",(0,i.jsx)(n.code,{children:"this.scene"})," and ",(0,i.jsx)(n.strong,{children:"not"})," ",(0,i.jsx)(n.code,{children:"this.game.scene"}),". I cannot iterate this enough."]}),"\n",(0,i.jsxs)(n.p,{children:["The Scene Plugin has a lot more methods available on it. For example, you can do ",(0,i.jsx)(n.code,{children:"this.scene.restart"}),", or ",(0,i.jsx)(n.code,{children:"this.scene.launch"})," from the Scene Plugin, but ",(0,i.jsx)(n.em,{children:"not"})," from the Scene Manager. If you try calling a method and it complains it doesn't exist, double-check you're not going in via ",(0,i.jsx)(n.code,{children:"game"})," by mistake, and correct your approach."]}),"\n",(0,i.jsx)(n.h3,{id:"moving-scenes",children:"Moving Scenes"}),"\n",(0,i.jsx)(n.p,{children:"There are 6 main commands you can use to arrange the Scene List:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"bringToTop()\nsendToBack()\nmoveUp()\nmoveDown()\nmoveAbove()\nmoveBelow()\n"})}),"\n",(0,i.jsx)(n.p,{children:"You access these methods via the Scene Plugin:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"this.scene.bringToTop();\n"})}),"\n",(0,i.jsx)(n.p,{children:"If you do not provide an argument then the action takes place on the current Scene, i.e. the one from which you called the method. So, the code above will try and move the current Scene to the top of the Scene List (assuming it is not already there.)"}),"\n",(0,i.jsx)(n.p,{children:"You can optionally provide a Scene to move:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"this.scene.bringToTop('SceneB');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will try and move the Scene referenced by the key ",(0,i.jsx)(n.code,{children:"SceneB"})," to the top of the Scene List. As well as a string you could also pass in a reference to the target Scene itself."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"moveAbove"})," and ",(0,i.jsx)(n.code,{children:"moveBelow"})," methods require you to provide a target Scene:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"this.scene.moveAbove('Game', 'PauseScreen');\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The code above will move the ",(0,i.jsx)(n.code,{children:"PauseScreen"})," Scene to be above the ",(0,i.jsx)(n.code,{children:"Game"})," Scene in the Scene List. If you omit the 2nd argument then it would try to move the current (calling) Scene to be above the ",(0,i.jsx)(n.code,{children:"Game"})," Scene."]}),"\n",(0,i.jsx)(n.h3,{id:"scene-ordering-demo",children:"Scene Ordering Demo"}),"\n",(0,i.jsx)(n.p,{children:"Using just these 6 methods you can construct complete Scene layouts. Let's make an example to demonstrate this in action, as it's the kind of thing that is easier to see running than to read about."}),"\n",(0,i.jsx)(n.p,{children:"Dull colored boxes, like in our previous example, are all good and well but it's time to spice things up. We're going to create an example with 7 Scenes. One of them will be our Controller Scene. This Scene will house the UI that you can use to manipulate the other Scenes. The other scenes will be unique graphical effects. Using a set of sci-fi game graphics we'll create Scenes for a rotating nebula, a glowing sun, an asteroid field, a planet, a space ship with an exhaust trail and some spinning space mines."}),"\n",(0,i.jsx)(n.p,{children:"All of the code and assets for this example can be found in the Phaser 3 Examples repo. Because there is quite a lot of code I'm only going to cover the parts that are directly related to moving Scenes, but it's well worth digging through the files to get some ideas for other aspects of how Phaser 3 works."}),"\n",(0,i.jsx)(n.p,{children:"The UI will allow you to select a Scene, then move it around the Scene List, toggle its active state and toggle visibility. Here is what it looks like:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"The buttons on the left allow you to select a Scene. The one with the light on is the current Scene, the name of which is also displayed in the LCD screen. Below it, you can see which index it currently holds in the Scene List. In the image above the Nebula Scene is index 1, which means it is rendering right at the back. Using the d-pad you can adjust this position. Finally, the two toggles on the right control the visible and active state of the selected Scene."}),"\n",(0,i.jsx)(n.p,{children:"All of the code for this UI can be found in the Controller.js file. It's nothing more than a few images and input events but you'll see in the events how we link from the Controller Scene to the target scene."}),"\n",(0,i.jsx)(n.p,{children:"As you've seen in the UI there are 6 Scenes to select from. In the following screen shot you can see them all running together. Click the shot for a link to the example so you can play with it:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"By using the controls you can re-arrange the Scenes. In the following we've hidden the Nebula entirely, bought the sun right to the front and made the ship fly behind the planet."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"Play with the controls and view the source until you've got a good feel for how the Scene List works."}),"\n",(0,i.jsx)(n.h2,{id:"spawning-multiple-scenes",children:"Spawning Multiple Scenes"}),"\n",(0,i.jsx)(n.p,{children:"Things are going to get a bit more crazy now. So far we have worked on the basis of one class = one Scene. However, that doesn't have to be the case. You can actually spawn multiple versions of the same Scene over and over again, all running at the same time if you so wish."}),"\n",(0,i.jsxs)(n.p,{children:["Here's a basic Scene class called ",(0,i.jsx)(n.code,{children:"Spawn"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class Spawn extends Phaser.Scene {\n\n    constructor (handle)\n    {\n        super(handle);\n    }\n\n    create ()\n    {\n        this.add.image(0, 0, 'phaserRulez');\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Rather than adding this to the scene array in the Game Config, let's create an instance of it at run-time:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let key = 'Spawn1';\nlet spawned = new Spawn(key);\n\nthis.scene.add(key, spawned, true);\n"})}),"\n",(0,i.jsx)(n.p,{children:"We define a key, create a new Spawn class and then add it into the Scene Manager (the final argument tells the Scene Manager to run it immediately)"}),"\n",(0,i.jsx)(n.p,{children:"Now, imagine that in a loop:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"for (let i = 0; i < 10; i++)\n{\n    let key = 'Spawn' + i;\n    let spawned = new Spawn(key);\n\n    this.scene.add(key, spawned, true);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Suddenly you've got 10 copies of the Spawn Scene running. You can get to any of them using their key:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let ref = this.scene.get('Spawn5');\n"})}),"\n",(0,i.jsx)(n.p,{children:"Once you have a reference to the Scene you can control it just like any other. Move it around the Scene List, pause it, hide it and so on."}),"\n",(0,i.jsx)(n.p,{children:"There's one more element we need to cover before we can build our demo showing this all off, and that's how Scenes render."}),"\n",(0,i.jsx)(n.h3,{id:"scene-rendering",children:"Scene Rendering"}),"\n",(0,i.jsx)(n.p,{children:"We've already covered in detail that the order of the Scene on the Scene List controls when it renders, and it's visible state controls if it renders at all. However, there's one last element to consider: the visual size of the Scene."}),"\n",(0,i.jsx)(n.p,{children:"By default a new Scene will be the same size as your game. It will create its own Camera Manager and the default camera will be set to your game dimensions. This is fine in lots of cases, but not all. You can change that behavior by setting the size of the default camera:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"class MiniScene extends Phaser.Scene {\n\n    constructor (handle)\n    {\n        super(handle);\n    }\n\n    create ()\n    {\n        this.cameras.main.setViewport(0, 0, 300, 200);\n    }\n\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above code tells our Scene that it has one camera that is 300 x 200 pixels in size and top-left positioned at 0 x 0. We can now add whatever we like to the Scene: graphics, images, animations, physics, but they will only render within the 300 x 200 window. Everything else gets clipped away."}),"\n",(0,i.jsx)(n.p,{children:"In this code the Scene is a fixed size and in a fixed position. It can be moved by simply moving the main camera:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"this.cameras.main.setPosition(128, 256);\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now the Scene will render at 128 x 256. It is still 300 x 200 in size, we only changed where within the game canvas it is rendering at. There are no restrictions on where the Scene can be placed (within reason) and they can be stacked on-top of each other as much as you like."}),"\n",(0,i.jsx)(n.p,{children:"If you factor in these two things: That Scenes can have a size other than the game canvas size, and you can position them anywhere, you should start to get an inkling of what's possible. Which leads us nicely onto our final demo."}),"\n",(0,i.jsx)(n.h3,{id:"multi-scene-demo",children:"Multi Scene Demo"}),"\n",(0,i.jsxs)(n.p,{children:["In order to demonstrate the ability to spawn multiple Scenes and move them around the canvas I'm going to create a mock desktop environment, leaning on my love of retro and borrowing the ",(0,i.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Workbench_(AmigaOS)",children:"Amiga workbench"})," as my source of inspiration. As with the previous demo everything has been split into single files and is available in the examples repo, so you can pick it apart at will."]}),"\n",(0,i.jsx)(n.p,{children:"The concept for this demo is as follows:"}),"\n",(0,i.jsx)(n.p,{children:"You will see an emulated Amiga desktop with a single disk icon. Clicking the icon will open a window containing six different demos. Clicking any of the icons will launch that demo. You can click the demo icons as many times as you like, it will just keep on spawning copies of the demos all over the screen. You can drag any of the windows around and doing so brings the window to the top of the Scene List. Finally, the demo will run at the size of the browser  and will respond to resize events."}),"\n",(0,i.jsx)(n.p,{children:"Although visually there are controls for resizing and closing the windows we're not going to implement that here for the sake of brevity. Feel free to do so if you wish though, and make sure to send me a link to your demo :)"}),"\n",(0,i.jsx)(n.p,{children:"The six different demos you can launch are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Eyes"})," - a pair of googly eyes that follow the pointer around the screen. If you spawn a bunch of these it can get quite surreal!"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Starfield"})," - a classic demo effect using a Blitter to draw some stars."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Juggler"})," - an example of a looped animation playing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Boing"})," - a small physics demo. The ball is bouncing within an Arcade Physics world set to the size of the window."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Clock"})," - a real clock based on your system time."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Invaders"})," - a playable Space Invaders game. Use the left/right cursors to control the ship. It will automatically fire. Spawn a whole bunch of these and you can play them all at once!"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Finally, here is a screen shot of each of the demos running. Click it to open the demo so you can experience it for yourself:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"INSERT PICTURE HERE"})}),"\n",(0,i.jsx)(n.p,{children:"Honestly, I'm quite pleased with this :) It's important to remember that every little window that opens is like its own Phaser Game instance in its own right, isolated from everything else."}),"\n",(0,i.jsx)(n.p,{children:"The above demo even runs on tablets, and likely phones too although the screen would be tiny. You can't play the invaders game on mobile but even so, you can spawn demos and drag them around. It's quite surprising how many you can get running before it starts to suffer."}),"\n",(0,i.jsx)(n.p,{children:"If you look at the code for each Scene you'll see they are fundamentally quite simple. There's very little in them that you will not have encountered before. The Controller is the Scene in charge of handling the 'desktop' and preloading all of the demo assets. It does all of the grunt work and then manages the windows as they open up. As with the Scene Ordering demo there's very little in the Controller beyond images and input events, although there is one thing worth covering in more detail: How to drag the Scenes around."}),"\n",(0,i.jsx)(n.h3,{id:"how-the-scene-dragging-is-done",children:"How the Scene dragging is done"}),"\n",(0,i.jsx)(n.p,{children:"There are lots of different ways you could achieve this effect, but for the sake of this demo I went with the following. When you click a demo icon, such as the Juggler, it calls this function:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"createWindow (func)\n{\n    var x = Phaser.Math.Between(400, 600);\n    var y = Phaser.Math.Between(64, 128);\n\n    var handle = 'window' + this.count++;\n\n    var win = this.add.zone(x, y, func.WIDTH, func.HEIGHT).setInteractive().setOrigin(0);\n\n    var demo = new func(handle, win);\n\n    this.input.setDraggable(win);\n\n    win.on('drag', function (pointer, dragX, dragY) {\n\n        this.x = dragX;\n        this.y = dragY;\n\n        demo.refresh()\n\n    });\n\n    this.scene.add(handle, demo, true);\n}\n\nthis.createWindow(Juggler);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We pass in a reference to the Scene class we wish to spawn. It then assigns it a new key (i.e. ",(0,i.jsx)(n.code,{children:"window7"}),") and creates a Zone Game Object within the Controller Scene. This Zone is in the same position and the same size as the Scene that was just created. It is set to be interactive and draggable. Finally, we listen for its drag event and then call the ",(0,i.jsx)(n.code,{children:"refresh"})," function on the Scene it is linked to. All ",(0,i.jsx)(n.code,{children:"refresh"})," does is call Camera setPosition and brings the Scene to the top."]}),"\n",(0,i.jsx)(n.p,{children:"Zones are non-rendering Game Objects. They have no visual attributes and don't take up any rendering time - but you can still make them interactive and click or drag them and we utilize this fact to link the invisible Zone to our visible Scene."}),"\n",(0,i.jsx)(n.p,{children:"It's not authentic because it means you can drag the window from any point, not just from the title bar like in a real OS, but that would be easy to change by just giving the Zone a smaller height. Alternatively, you could allow the Scene to deal with the input events itself and drag it from there, but I liked the simplicity of this method so kept it in this demo. Remember, there's rarely one way to skin a cat."}),"\n",(0,i.jsx)(n.p,{children:"I hope you've had fun learning about what Scenes can do, how they work and how to visually manipulate them. As mentioned before, all of the code can be found in the repo and will work with Phaser 3.7.0 and above."})]})}function d(e={}){let{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:function(e,n,t){t.d(n,{R:()=>o,x:()=>r});var s=t(96540);let i={},a=s.createContext(i);function o(e){let n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["4744"],{66031:function(e,n,s){s.r(n),s.d(n,{metadata:()=>t,default:()=>o,frontMatter:()=>a,contentTitle:()=>d,toc:()=>c,assets:()=>l});var t=JSON.parse('{"id":"namespace/Phaser.Geom.Mesh","title":"Phaser.Geom.Mesh","description":"Scope:","source":"@site/api-documentation_versioned_docs/version-3.86.0/namespace/Phaser.Geom.Mesh.md","sourceDirName":"namespace","slug":"/namespace/geom-mesh","permalink":"/api-documentation/3.86.0/namespace/geom-mesh","draft":false,"unlisted":false,"tags":[],"version":"3.86.0","frontMatter":{"visibility":"public","slug":"geom-mesh","title":"Phaser.Geom.Mesh","seoTitle":"Phaser.Geom.Mesh","seoDescription":"Phaser v3.86.0 Documentation for","ogImage":null},"sidebar":"PhaserApiSidebar","previous":{"title":"Phaser.Geom.Intersects","permalink":"/api-documentation/3.86.0/namespace/geom-intersects"},"next":{"title":"Phaser.Geom","permalink":"/api-documentation/3.86.0/namespace/geom"}}'),r=s(74848),i=s(28453);let a={visibility:"public",slug:"geom-mesh",title:"Phaser.Geom.Mesh",seoTitle:"Phaser.Geom.Mesh",seoDescription:"Phaser v3.86.0 Documentation for",ogImage:null},d="Static functions",l={},c=[{value:"GenerateGridVerts",id:"generategridverts",level:2},{value:"&lt;static&gt; GenerateGridVerts(config)",id:"static-generategridvertsconfig",level:3},{value:"GenerateObjVerts",id:"generateobjverts",level:2},{value:"&lt;static&gt; GenerateObjVerts(data, [mesh], [scale], [x], [y], [z], [rotateX], [rotateY], [rotateZ], [zIsUp])",id:"static-generateobjvertsdata-mesh-scale-x-y-z-rotatex-rotatey-rotatez-zisup",level:3},{value:"GenerateVerts",id:"generateverts",level:2},{value:"&lt;static&gt; GenerateVerts(vertices, uvs, [indicies], [containsZ], [normals], [colors], [alphas], [flipUV])",id:"static-generatevertsvertices-uvs-indicies-containsz-normals-colors-alphas-flipuv",level:3},{value:"ParseObj",id:"parseobj",level:2},{value:"&lt;static&gt; ParseObj(data, [flipUV])",id:"static-parseobjdata-flipuv",level:3},{value:"ParseObjMaterial",id:"parseobjmaterial",level:2},{value:"&lt;static&gt; ParseObjMaterial(mtl)",id:"static-parseobjmaterialmtl",level:3},{value:"RotateFace",id:"rotateface",level:2},{value:"&lt;static&gt; RotateFace(face, angle, [cx], [cy])",id:"static-rotatefaceface-angle-cx-cy",level:3}];function h(e){let n={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Scope:\nstatic"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/index.js#L7",children:"src/geom/mesh/index.js#L7"})]}),"\n"]}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"static-functions",children:"Static functions"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../class/geom-mesh-face",children:"Face"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"../class/geom-mesh-vertex",children:"Vertex"})}),"\n"]}),"\n",(0,r.jsx)(n.h1,{id:"static-functions-1",children:"Static functions"}),"\n",(0,r.jsx)(n.h2,{id:"generategridverts",children:"GenerateGridVerts"}),"\n",(0,r.jsx)(n.h3,{id:"static-generategridvertsconfig",children:"<static> GenerateGridVerts(config)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"Creates a grid of vertices based on the given configuration object and optionally adds it to a Mesh."}),"\n",(0,r.jsx)(n.p,{children:"The size of the grid is given in pixels. An example configuration may be:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"{ width: 256, height: 256, widthSegments: 2, heightSegments: 2, tile: true }"})}),"\n",(0,r.jsx)(n.p,{children:"This will create a grid 256 x 256 pixels in size, split into 2 x 2 segments, with"}),"\n",(0,r.jsx)(n.p,{children:"the texture tiling across the cells."}),"\n",(0,r.jsx)(n.p,{children:"You can split the grid into segments both vertically and horizontally. This will"}),"\n",(0,r.jsx)(n.p,{children:"generate two faces per grid segment as a result."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"tile"})," parameter allows you to control if the tile will repeat across the grid"]}),"\n",(0,r.jsx)(n.p,{children:"segments, or be displayed in full."}),"\n",(0,r.jsxs)(n.p,{children:["If adding this grid to a Mesh you can offset the grid via the ",(0,r.jsx)(n.code,{children:"x"})," and ",(0,r.jsx)(n.code,{children:"y"})," properties."]}),"\n",(0,r.jsx)(n.p,{children:"UV coordinates are generated based on the given texture and frame in the config. For"}),"\n",(0,r.jsx)(n.p,{children:"example, no frame is given, the UVs will be in the range 0 to 1. If a frame is given,"}),"\n",(0,r.jsx)(n.p,{children:"such as from a texture atlas, the UVs will be generated within the range of that frame."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"config"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#GenerateGridConfig",children:"Phaser.Types.Geom.Mesh.GenerateGridConfig"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"A Grid configuration object."})]})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#GenerateGridVertsResult",children:"Phaser.Types.Geom.Mesh.GenerateGridVertsResult"})," - A Grid Result object, containing the generated vertices and indicies."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/GenerateGridVerts.js#L17",children:"src/geom/mesh/GenerateGridVerts.js#L17"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateobjverts",children:"GenerateObjVerts"}),"\n",(0,r.jsx)(n.h3,{id:"static-generateobjvertsdata-mesh-scale-x-y-z-rotatex-rotatey-rotatez-zisup",children:"<static> GenerateObjVerts(data, [mesh], [scale], [x], [y], [z], [rotateX], [rotateY], [rotateZ], [zIsUp])"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"This method will return an object containing Face and Vertex instances, generated"}),"\n",(0,r.jsx)(n.p,{children:"from the parsed triangulated OBJ Model data given to this function."}),"\n",(0,r.jsx)(n.p,{children:"The obj data should have been parsed in advance via the ParseObj function:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\nvar data = Phaser.Geom.Mesh.ParseObj(rawData, flipUV);\n\n\n\nvar results = GenerateObjVerts(data);\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, you can parse obj files loaded via the OBJFile loader:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\npreload ()\n\n{\n\n  this.load.obj('alien', 'assets/3d/alien.obj);\n\n}\n\n\n\nvar results = GenerateObjVerts(this.cache.obj.get('alien));\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Make sure your 3D package has triangulated the model data prior to exporting it."}),"\n",(0,r.jsx)(n.p,{children:"You can use the data returned by this function to populate the vertices of a Mesh Game Object."}),"\n",(0,r.jsx)(n.p,{children:"You may add multiple models to a single Mesh, although they will act as one when"}),"\n",(0,r.jsx)(n.p,{children:"moved or rotated. You can scale the model data, should it be too small (or large) to visualize."}),"\n",(0,r.jsxs)(n.p,{children:["You can also offset the model via the ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"})," and ",(0,r.jsx)(n.code,{children:"z"})," parameters."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"default"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"data"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#OBJData",children:"Phaser.Types.Geom.Mesh.OBJData"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"The parsed OBJ model data."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"mesh"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/class/gameobjects-mesh",children:"Phaser.GameObjects.Mesh"})}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{}),(0,r.jsxs)(n.td,{children:["An optional Mesh Game Object. If given, the generated Faces will be automatically added to this Mesh. Set to ",(0,r.jsx)(n.code,{children:"null"})," to skip."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"scale"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"An amount to scale the model data by. Use this if the model has exported too small, or large, to see."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"x"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Translate the model x position by this amount."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"y"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Translate the model y position by this amount."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"z"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Translate the model z position by this amount."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"rotateX"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Rotate the model on the x axis by this amount, in radians."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"rotateY"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Rotate the model on the y axis by this amount, in radians."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"rotateZ"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"0"}),(0,r.jsx)(n.td,{children:"Rotate the model on the z axis by this amount, in radians."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"zIsUp"}),(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"true"}),(0,r.jsx)(n.td,{children:"Is the z axis up (true), or is y axis up (false)?"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#GenerateVertsResult",children:"Phaser.Types.Geom.Mesh.GenerateVertsResult"})," - The parsed Face and Vertex objects."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/GenerateObjVerts.js#L16",children:"src/geom/mesh/GenerateObjVerts.js#L16"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"generateverts",children:"GenerateVerts"}),"\n",(0,r.jsx)(n.h3,{id:"static-generatevertsvertices-uvs-indicies-containsz-normals-colors-alphas-flipuv",children:"<static> GenerateVerts(vertices, uvs, [indicies], [containsZ], [normals], [colors], [alphas], [flipUV])"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"Generates a set of Face and Vertex objects by parsing the given data."}),"\n",(0,r.jsxs)(n.p,{children:["This method will take vertex data in one of two formats, based on the ",(0,r.jsx)(n.code,{children:"containsZ"})," parameter."]}),"\n",(0,r.jsxs)(n.p,{children:["If your vertex data are ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"})," pairs, then ",(0,r.jsx)(n.code,{children:"containsZ"})," should be ",(0,r.jsx)(n.code,{children:"false"})," (this is the default)"]}),"\n",(0,r.jsxs)(n.p,{children:["If your vertex data is groups of ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"})," and ",(0,r.jsx)(n.code,{children:"z"})," values, then the ",(0,r.jsx)(n.code,{children:"containsZ"})," parameter must be true."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"uvs"})," parameter is a numeric array consisting of ",(0,r.jsx)(n.code,{children:"u"})," and ",(0,r.jsx)(n.code,{children:"v"})," pairs."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"normals"})," parameter is a numeric array consisting of ",(0,r.jsx)(n.code,{children:"x"}),", ",(0,r.jsx)(n.code,{children:"y"})," vertex normal values and, if ",(0,r.jsx)(n.code,{children:"containsZ"})," is true, ",(0,r.jsx)(n.code,{children:"z"})," values as well."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"indicies"})," parameter is an optional array that, if given, is an indexed list of vertices to be added."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"colors"})," parameter is an optional array, or single value, that if given sets the color of each vertex created."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"alphas"})," parameter is an optional array, or single value, that if given sets the alpha of each vertex created."]}),"\n",(0,r.jsxs)(n.p,{children:["When providing indexed data it is assumed that ",(0,r.jsx)(n.em,{children:"all"})," of the arrays are indexed, not just the vertices."]}),"\n",(0,r.jsx)(n.p,{children:"The following example will create a 256 x 256 sized quad using an index array:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"\nconst vertices = [\n\n  -128, 128,\n\n  128, 128,\n\n  -128, -128,\n\n  128, -128\n\n];\n\n\n\nconst uvs = [\n\n  0, 1,\n\n  1, 1,\n\n  0, 0,\n\n  1, 0\n\n];\n\n\n\nconst indices = [ 0, 2, 1, 2, 3, 1 ];\n\n\n\nGenerateVerts(vertices, uvs, indicies);\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"If the data is not indexed, it's assumed that the arrays all contain sequential data."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"default"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"vertices"}),(0,r.jsx)(n.td,{children:"Array.<number>"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{}),(0,r.jsxs)(n.td,{children:["The vertices array. Either ",(0,r.jsx)(n.code,{children:"xy"})," pairs, or ",(0,r.jsx)(n.code,{children:"xyz"})," if the ",(0,r.jsx)(n.code,{children:"containsZ"})," parameter is ",(0,r.jsx)(n.code,{children:"true"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"uvs"}),(0,r.jsx)(n.td,{children:"Array.<number>"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"The UVs pairs array."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"indicies"}),(0,r.jsx)(n.td,{children:"Array.<number>"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{}),(0,r.jsxs)(n.td,{children:["Optional vertex indicies array. If you don't have one, pass ",(0,r.jsx)(n.code,{children:"null"})," or an empty array."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"containsZ"}),(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsxs)(n.td,{children:["Does the vertices data include a ",(0,r.jsx)(n.code,{children:"z"})," component?"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"normals"}),(0,r.jsx)(n.td,{children:"Array.<number>"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{}),(0,r.jsxs)(n.td,{children:["Optional vertex normals array. If you don't have one, pass ",(0,r.jsx)(n.code,{children:"null"})," or an empty array."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"colors"}),(0,r.jsx)(n.td,{children:"number | Array.<number>"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:'"0xffffff"'}),(0,r.jsx)(n.td,{children:"An array of colors, one per vertex, or a single color value applied to all vertices."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"alphas"}),(0,r.jsx)(n.td,{children:"number | Array.<number>"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"An array of alpha values, one per vertex, or a single alpha value applied to all vertices."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"flipUV"}),(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"Flip the UV coordinates?"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#GenerateVertsResult",children:"Phaser.Types.Geom.Mesh.GenerateVertsResult"})," - The parsed Face and Vertex objects."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/GenerateVerts.js#L10",children:"src/geom/mesh/GenerateVerts.js#L10"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"parseobj",children:"ParseObj"}),"\n",(0,r.jsx)(n.h3,{id:"static-parseobjdata-flipuv",children:"<static> ParseObj(data, [flipUV])"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"Parses a Wavefront OBJ File, extracting the models from it and returning them in an array."}),"\n",(0,r.jsxs)(n.p,{children:["The model data ",(0,r.jsx)(n.em,{children:"must"})," be triangulated for a Mesh Game Object to be able to render it."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"default"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"data"}),(0,r.jsx)(n.td,{children:"string"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"The OBJ File data as a raw string."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"flipUV"}),(0,r.jsx)(n.td,{children:"boolean"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"true"}),(0,r.jsx)(n.td,{children:"Flip the UV coordinates?"})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," ",(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/typedef/types-geom-mesh#OBJData",children:"Phaser.Types.Geom.Mesh.OBJData"})," - The parsed model and material data."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/ParseObj.js#L226",children:"src/geom/mesh/ParseObj.js#L226"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"parseobjmaterial",children:"ParseObjMaterial"}),"\n",(0,r.jsx)(n.h3,{id:"static-parseobjmaterialmtl",children:"<static> ParseObjMaterial(mtl)"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"Takes a Wavefront Material file and extracts the diffuse reflectivity of the named"}),"\n",(0,r.jsx)(n.p,{children:"materials, converts them to integer color values and returns them."}),"\n",(0,r.jsxs)(n.p,{children:["This is used internally by the ",(0,r.jsx)(n.code,{children:"addOBJ"})," and ",(0,r.jsx)(n.code,{children:"addModel"})," methods, but is exposed for"]}),"\n",(0,r.jsx)(n.p,{children:"public consumption as well."}),"\n",(0,r.jsxs)(n.p,{children:["Note this only works with diffuse values, specified in the ",(0,r.jsx)(n.code,{children:"Kd r g b"})," format, where"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"g"})," and ",(0,r.jsx)(n.code,{children:"b"})," are optional, but ",(0,r.jsx)(n.code,{children:"r"})," is required. It does not support spectral rfl files,"]}),"\n",(0,r.jsxs)(n.p,{children:["or any other material statement (such as ",(0,r.jsx)(n.code,{children:"Ka"})," or ",(0,r.jsx)(n.code,{children:"Ks"}),")"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsx)(n.tbody,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"mtl"}),(0,r.jsx)(n.td,{children:"string"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsxs)(n.td,{children:["The OBJ MTL file as a raw string, i.e. loaded via ",(0,r.jsx)(n.code,{children:"this.load.text"}),"."]})]})})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Returns:"})," object - The parsed material colors, where each property of the object matches the material name."]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/ParseObjMaterial.js#L9",children:"src/geom/mesh/ParseObjMaterial.js#L9"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsx)(n.h2,{id:"rotateface",children:"RotateFace"}),"\n",(0,r.jsx)(n.h3,{id:"static-rotatefaceface-angle-cx-cy",children:"<static> RotateFace(face, angle, [cx], [cy])"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Description:"})}),"\n",(0,r.jsx)(n.p,{children:"Rotates the vertices of a Face to the given angle."}),"\n",(0,r.jsx)(n.p,{children:"The actual vertex positions are adjusted, not their transformed positions."}),"\n",(0,r.jsx)(n.p,{children:"Therefore, this updates the vertex data directly."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"name"}),(0,r.jsx)(n.th,{children:"type"}),(0,r.jsx)(n.th,{children:"optional"}),(0,r.jsx)(n.th,{children:"description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"face"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.a,{href:"/api-documentation/3.86.0/class/geom-mesh-face",children:"Phaser.Geom.Mesh.Face"})}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"The Face to rotate."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"angle"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"The angle to rotate to, in radians."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"cx"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"An optional center of rotation. If not given, the Face in-center is used."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"cy"}),(0,r.jsx)(n.td,{children:"number"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"An optional center of rotation. If not given, the Face in-center is used."})]})]})]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:["Source: ",(0,r.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.86.0/src/geom/mesh/RotateFace.js#L7",children:"src/geom/mesh/RotateFace.js#L7"}),(0,r.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{})]})}function o(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:function(e,n,s){s.d(n,{R:()=>a,x:()=>d});var t=s(96540);let r={},i=t.createContext(r);function a(e){let n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["20801"],{42498:function(e,n,t){t.r(n),t.d(n,{metadata:()=>s,default:()=>c,frontMatter:()=>o,contentTitle:()=>r,toc:()=>h,assets:()=>l});var s=JSON.parse('{"id":"phaser/concepts/gameobjects/components","title":"Game Object Components","description":"A Guide to the Phaser Components System","source":"@site/docs/phaser/concepts/gameobjects/components.md","sourceDirName":"phaser/concepts/gameobjects","slug":"/phaser/concepts/gameobjects/components","permalink":"/phaser/concepts/gameobjects/components","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"visibility":"public","slug":"components","seoTitle":"Game Object Components","seoDescription":"A Guide to the Phaser Components System","title":"Game Object Components","description":"A Guide to the Phaser Components System"},"sidebar":"PhaserSidebar","previous":{"title":"Game Objects","permalink":"/phaser/concepts/gameobjects"},"next":{"title":"Game Object Factories","permalink":"/phaser/concepts/gameobjects/factories"}}'),a=t(74848),i=t(28453);let o={visibility:"public",slug:"components",seoTitle:"Game Object Components",seoDescription:"A Guide to the Phaser Components System",title:"Game Object Components",description:"A Guide to the Phaser Components System"},r,l={},h=[{value:"Alpha Component",id:"alpha-component",level:2},{value:"Per Vertex Alpha",id:"per-vertex-alpha",level:3},{value:"Alpha and Parents",id:"alpha-and-parents",level:3},{value:"Blend Mode Component",id:"blend-mode-component",level:2},{value:"Blend Mode Constants",id:"blend-mode-constants",level:3},{value:"Canvas vs. WebGL",id:"canvas-vs-webgl",level:3},{value:"WebGL Performance Considerations",id:"webgl-performance-considerations",level:3},{value:"Bounds Component",id:"bounds-component",level:2},{value:"Bounds Related Points",id:"bounds-related-points",level:3},{value:"Crop Component",id:"crop-component",level:2},{value:"Crop Limitations",id:"crop-limitations",level:3},{value:"Depth Component",id:"depth-component",level:2},{value:"Depth Updates",id:"depth-updates",level:3},{value:"Depth and Containers",id:"depth-and-containers",level:3},{value:"Flip Component",id:"flip-component",level:2},{value:"Toggle and Reset a Flip",id:"toggle-and-reset-a-flip",level:3},{value:"Flip vs. Scale",id:"flip-vs-scale",level:3},{value:"Mask Component",id:"mask-component",level:2},{value:"How Masks Work in Phaser",id:"how-masks-work-in-phaser",level:3},{value:"Geometry Mask",id:"geometry-mask",level:3},{value:"Bitmap Mask",id:"bitmap-mask",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Origin Component",id:"origin-component",level:2},{value:"The Display Origin",id:"the-display-origin",level:3},{value:"Custom Frame Pivot",id:"custom-frame-pivot",level:3},{value:"Pipeline Component",id:"pipeline-component",level:2},{value:"Pipeline Data",id:"pipeline-data",level:3},{value:"Scroll Factor Component",id:"scroll-factor-component",level:2},{value:"Size Component",id:"size-component",level:2},{value:"Display Size",id:"display-size",level:3},{value:"Parent Size",id:"parent-size",level:3},{value:"Transform Component",id:"transform-component",level:2},{value:"Position",id:"position",level:3},{value:"Scale",id:"scale",level:3},{value:"Rotation",id:"rotation",level:3},{value:"Local and World Transforms",id:"local-and-world-transforms",level:3},{value:"Visible Component",id:"visible-component",level:2},{value:"Parent Visibility",id:"parent-visibility",level:3}];function d(e){let n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"alpha-component",children:"Alpha Component"}),"\n",(0,a.jsx)(n.p,{children:"The Alpha Component is responsible for setting the alpha value of a Game Object. This is a value between 0 and 1. A value of 1 is fully opaque, where-as a value of 0 is fully transparent. By default, Game Objects have an alpha value of 1."}),"\n",(0,a.jsxs)(n.p,{children:["The current local alpha value of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"alpha"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const alpha = player.alpha;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the alpha you can use the chainable ",(0,a.jsx)(n.code,{children:"setAlpha"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setAlpha(alpha);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"alpha"})," property directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.alpha = alpha;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["By default, Game Objects will have an alpha value of 1. This means they will be fully visible. You can reset the alpha of a Game Object either by setting its ",(0,a.jsx)(n.code,{children:"alpha"})," property to 1, or by calling the chainable ",(0,a.jsx)(n.code,{children:"clearAlpha"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.clearAlpha();\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can use this property to create effects such as a Game Object 'fading out' over time, or to make a Game Object appear to be semi-transparent. As an internal optimization, Game Objects with an alpha value of 0 will be skipped by the renderer."}),"\n",(0,a.jsx)(n.h3,{id:"per-vertex-alpha",children:"Per Vertex Alpha"}),"\n",(0,a.jsxs)(n.p,{children:["For some Game Objects it's possible to set a different alpha value per corner. This is known as vertex alpha. It allows you to create effects such as a Game Object fading out from one corner to another, or to make a Game Object appear to be semi-transparent at one corner, but not the other. Not all Game Objects support vertex alpha, but those that do will have a ",(0,a.jsx)(n.code,{children:"setAlpha"})," method that accepts 4 values, one for each corner."]}),"\n",(0,a.jsx)(n.p,{children:"The corners are given in the order: Top Left, Top Right, Bottom Left and Bottom Right:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setAlpha(topLeft, topRight, bottomLeft, bottomRight);\n"})}),"\n",(0,a.jsx)(n.p,{children:"You can also set the properties directly:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.alphaTopLeft = topLeft;\nplayer.alphaTopRight = topRight;\nplayer.alphaBottomLeft = bottomLeft;\nplayer.alphaBottomRight = bottomRight;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The ability to set per-vertex alpha is a WebGL only feature."}),"\n",(0,a.jsx)(n.h3,{id:"alpha-and-parents",children:"Alpha and Parents"}),"\n",(0,a.jsx)(n.p,{children:"When a Game Object has its alpha property set it will multiply its alpha value with that of its parent Container, if it has one. For example, if you have a parent Game Object with an alpha value of 0.5, and a child with an alpha value of 0.5, then the child will be rendered at 0.25 alpha as it's multiplied with the parent's alpha:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setAlpha(0.5);\nchild.setAlpha(0.5);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"blend-mode-component",children:"Blend Mode Component"}),"\n",(0,a.jsx)(n.p,{children:"The Blend Mode Component allows Game Objects to set a blend mode which is used during rendering. Blend modes allow for different types of combining / blending of the pixels in Game Objects with those of the background."}),"\n",(0,a.jsxs)(n.p,{children:["The current blend mode of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"blendMode"})," numeric property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const blendMode = sprite.blendMode;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can set the blend mode of a Game Object using the chainable ",(0,a.jsx)(n.code,{children:"setBlendMode"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setBlendMode(mode);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"blendMode"})," property directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.blendMode = mode;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The mode value can be one of the ",(0,a.jsx)(n.code,{children:"BlendModes"})," constants, such as ",(0,a.jsx)(n.code,{children:"Phaser.BlendModes.SCREEN"}),". It can also be a string, such as ",(0,a.jsx)(n.code,{children:"SCREEN"}),", or an integer, such as ",(0,a.jsx)(n.code,{children:"3"}),". If you give a string, it must be all upper-case and match exactly those available in the ",(0,a.jsx)(n.code,{children:"BlendModes"})," constants list. If you give an integer, it must be a valid Blend Mode constant ID from the list below."]}),"\n",(0,a.jsxs)(n.p,{children:["The default value is zero, which is the ",(0,a.jsx)(n.code,{children:"NORMAL"})," blend mode."]}),"\n",(0,a.jsx)(n.h3,{id:"blend-mode-constants",children:"Blend Mode Constants"}),"\n",(0,a.jsx)(n.p,{children:"The available blend modes are:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"ID"}),(0,a.jsx)(n.th,{children:"Constant"}),(0,a.jsx)(n.th,{children:"Description"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"0"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"NORMAL"})}),(0,a.jsx)(n.td,{children:"Normal blend mode. For Canvas and WebGL."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"1"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"ADD"})}),(0,a.jsx)(n.td,{children:"Add blend mode. For Canvas and WebGL."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"2"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"MULTIPLY"})}),(0,a.jsx)(n.td,{children:"Multiply blend mode. For Canvas and WebGL."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"3"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SCREEN"})}),(0,a.jsx)(n.td,{children:"Screen blend mode. For Canvas and WebGL."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"4"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"OVERLAY"})}),(0,a.jsx)(n.td,{children:"Overlay blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"5"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DARKEN"})}),(0,a.jsx)(n.td,{children:"Darken blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"6"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"LIGHTEN"})}),(0,a.jsx)(n.td,{children:"Lighten blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"7"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"COLOR_DODGE"})}),(0,a.jsx)(n.td,{children:"Color dodge blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"8"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"COLOR_BURN"})}),(0,a.jsx)(n.td,{children:"Color burn blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"9"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"HARD_LIGHT"})}),(0,a.jsx)(n.td,{children:"Hard light blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"10"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SOFT_LIGHT"})}),(0,a.jsx)(n.td,{children:"Soft light blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"11"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DIFFERENCE"})}),(0,a.jsx)(n.td,{children:"Difference blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"12"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"EXCLUSION"})}),(0,a.jsx)(n.td,{children:"Exclusion blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"13"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"HUE"})}),(0,a.jsx)(n.td,{children:"Hue blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"14"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SATURATION"})}),(0,a.jsx)(n.td,{children:"Saturation blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"15"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"COLOR"})}),(0,a.jsx)(n.td,{children:"Color blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"16"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"LUMINOSITY"})}),(0,a.jsx)(n.td,{children:"Luminosity blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"17"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"ERASE"})}),(0,a.jsx)(n.td,{children:"Erase blend mode. For Canvas and WebGL."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"18"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SOURCE_IN"})}),(0,a.jsx)(n.td,{children:"Source in blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"19"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SOURCE_OUT"})}),(0,a.jsx)(n.td,{children:"Source out blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"20"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"SOURCE_ATOP"})}),(0,a.jsx)(n.td,{children:"Source atop blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"21"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DESTINATION_OVER"})}),(0,a.jsx)(n.td,{children:"Destination over blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"22"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DESTINATION_IN"})}),(0,a.jsx)(n.td,{children:"Destination in blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"23"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DESTINATION_OUT"})}),(0,a.jsx)(n.td,{children:"Destination out blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"24"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"DESTINATION_ATOP"})}),(0,a.jsx)(n.td,{children:"Destination atop blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"25"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"LIGHTER"})}),(0,a.jsx)(n.td,{children:"Xor blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"26"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"COPY"})}),(0,a.jsx)(n.td,{children:"Copy blend mode. For Canvas only."})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"27"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"XOR"})}),(0,a.jsx)(n.td,{children:"Xor blend mode. For Canvas only."})]})]})]}),"\n",(0,a.jsx)(n.h3,{id:"canvas-vs-webgl",children:"Canvas vs. WebGL"}),"\n",(0,a.jsx)(n.p,{children:"The Canvas Renderer supports all blend modes. However, the WebGL Renderer only supports the following blend modes:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"NORMAL"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"ADD"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"MULTIPLY"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"SCREEN"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"ERASE"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["If you set a blend mode that is not supported by the WebGL Renderer, it will instead use the ",(0,a.jsx)(n.code,{children:"NORMAL"})," blend mode."]}),"\n",(0,a.jsx)(n.p,{children:"Under WebGL you can create your own custom blend modes."}),"\n",(0,a.jsxs)(n.p,{children:["The Canvas Renderer will use the Canvas ",(0,a.jsx)(n.code,{children:"globalCompositeOperation"})," feature which is part of the browsers Canvas API. This is why it has so many additional blend modes available."]}),"\n",(0,a.jsx)(n.h3,{id:"webgl-performance-considerations",children:"WebGL Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"The Phaser WebGL Renderer will use the built-in GL Blending functions, which are extremely fast. However, they are more limited in scope than the Canvas Renderer, which is why you only have 5 available by default. Because they use the GL blend functions it means they require a batch flush before they can be set. So, if you have a series of Game Objects that are together in a batch, but one of them has a blend mode set different from the rest, the renderer will stop the batch, draw them all, set the blend mode, draw that one Game Object, then start a new batch again for the rest."}),"\n",(0,a.jsx)(n.p,{children:"While modern GPUs are designed to handle tasks like this with ease, you should always be mindful of the potential impact this constant batch flushing can have. If you need to change blend modes often, try to organize your Game Objects so that those with shared blend modes are added to the display list consecutively, without breaks, as this will allow them to be rendered in as few batches as possible."}),"\n",(0,a.jsx)(n.h2,{id:"bounds-component",children:"Bounds Component"}),"\n",(0,a.jsx)(n.p,{children:"The Bounds Component is responsible for providing methods you can call that will return various bounds related values from a Game Object."}),"\n",(0,a.jsx)(n.p,{children:"The 'bounds' of a Game Object can be summed-up as a rectangle that fully encapsulates the visual bounds of the Game Object, taking into account its scale and rotation."}),"\n",(0,a.jsx)(n.p,{children:"Not all Game Objects have a bounds. For example, the Graphics Game Object does not have an instrinsic bounds because of the way in which it works. However, most texture-based Game Objects, such as Sprites, Text and TileSprites can return their bounds."}),"\n",(0,a.jsx)(n.p,{children:"If the Game Object has a parent container, then its bounds will be factored based on its influence from the Container."}),"\n",(0,a.jsxs)(n.p,{children:["The bounds of a Game Object can be obtained by calling its ",(0,a.jsx)(n.code,{children:"getBounds"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const bounds = sprite.getBounds();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will return a ",(0,a.jsx)(n.code,{children:"Rectangle"})," Shape object, where the ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," values are the top-left of the bounds, and the ",(0,a.jsx)(n.code,{children:"width"})," and ",(0,a.jsx)(n.code,{children:"height"})," values are the width and height of the bounds."]}),"\n",(0,a.jsxs)(n.p,{children:["You can also pass in a Rectangle object to the ",(0,a.jsx)(n.code,{children:"getBounds"})," method, and it will set the values based on the bounds of the Game Object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const rect = new Phaser.Geom.Rectangle();\n\nsprite.getBounds(rect);\n"})}),"\n",(0,a.jsx)(n.p,{children:"If you don't pass in a Rectangle then a new instance will be created and returned to you. So, if you need to call this method frequently, pass in a Rectangle instance to help ease object creation."}),"\n",(0,a.jsx)(n.p,{children:"Every time you call this method the bounds are calculated fresh. They are not cached internally, or updated automatically. So be aware of this if you are using bounds in any kind of update loop, or at scale."}),"\n",(0,a.jsx)(n.h3,{id:"bounds-related-points",children:"Bounds Related Points"}),"\n",(0,a.jsxs)(n.p,{children:["As well as the ",(0,a.jsx)(n.code,{children:"getBounds"})," method, there are also a number of other methods available that return specific points from the bounds of the Game Object. If you don't require the full bounds then getting just the point you do need is more efficient."]}),"\n",(0,a.jsx)(n.p,{children:"These methods are:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getTopLeft"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getTopCenter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getTopRight"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getLeftCenter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getCenter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getRightCenter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getBottomLeft"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getBottomCenter"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.code,{children:"getBottomRight"})}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["They all operate in the same way. You can optionally pass them a Vector2 instance in which to store the resulting point, or they can create one for you. They all also have the ",(0,a.jsx)(n.code,{children:"includeParent"})," boolean, which allows them to involve a parent container, if the Game Object has one, in the calculations, or not."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, here is how to use the ",(0,a.jsx)(n.code,{children:"getTopLeft"})," method without factoring in a parent:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const point = sprite.getTopLeft();\n"})}),"\n",(0,a.jsx)(n.p,{children:"And here is how to use it, but factor in a parent:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const point = sprite.getTopLeft(null, true);\n"})}),"\n",(0,a.jsx)(n.p,{children:"And here is how to use it, but factor in a parent, and store the result in a pre-created Vector2:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const point = new Phaser.Math.Vector2();\n\nsprite.getTopLeft(point, true);\n"})}),"\n",(0,a.jsx)(n.p,{children:"All of the listed methods can be used in this way."}),"\n",(0,a.jsx)(n.p,{children:"None of the bounds methods allow you to set the bounds. They are all 'read only' methods."}),"\n",(0,a.jsx)(n.h2,{id:"crop-component",children:"Crop Component"}),"\n",(0,a.jsx)(n.p,{children:"The Crop Component allows texture-based Game Objects to 'crop' themselves. A crop is a rectangle that limits the area of the texture frame that is visible during rendering."}),"\n",(0,a.jsx)(n.p,{children:"Cropping a Game Object does not change its size, dimensions, physics body or hit area, it just visually changes what you can see of it during the render-pass."}),"\n",(0,a.jsxs)(n.p,{children:["The current crop state of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"isCropped"})," boolean:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const isCropped = player.isCropped;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To crop a Game Object you can use the chainable ",(0,a.jsx)(n.code,{children:"setCrop"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setCrop(x, y, width, height);\n"})}),"\n",(0,a.jsx)(n.p,{children:"It takes four arguments that represent the x/y coordinate to start the crop from, and the width and height of the crop. A crop is always a rectangle and cannot be any other shape."}),"\n",(0,a.jsx)(n.p,{children:"The coordinates are relative to the Game Object, so 0 x 0 is the top-left of the Game Object texture frame."}),"\n",(0,a.jsx)(n.p,{children:"Instead of passing in numeric values directly, or you can provide a single Rectangle Geometry object instance as the first and only parameter:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const rect = new Phaser.Geom.Rectangle(x, y, width, height);\n\nplayer.setCrop(rect);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that this is a Geometry object, not a Rectangle Shape object."}),"\n",(0,a.jsxs)(n.p,{children:["One set, to adjust the crop you can call the ",(0,a.jsx)(n.code,{children:"setCrop"})," method again with new values, or pass in an updated Rectangle instance."]}),"\n",(0,a.jsxs)(n.p,{children:["If you wish to remove the crop from a Game Object, resetting it to show the entire texture again, call the ",(0,a.jsx)(n.code,{children:"setCrop"})," method with no arguments:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setCrop();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"crop-limitations",children:"Crop Limitations"}),"\n",(0,a.jsx)(n.p,{children:"Internally, the crop works by adjusting the textures UV coordinates prior to rendering. Therefore the crop can only ever be a rectangle that fits inside the existing texture area."}),"\n",(0,a.jsx)(n.p,{children:"You cannot crop a Game Object to show more of the texture than originally allowed, or use any other shape than a rectangle."}),"\n",(0,a.jsx)(n.p,{children:"Because it works by just adjusting the UV coordinates it does provide a way to do super-fast masking, if you need a rectangular mask."}),"\n",(0,a.jsx)(n.h2,{id:"depth-component",children:"Depth Component"}),"\n",(0,a.jsx)(n.p,{children:"The Depth Component allows Game Objects to be sorted within the Scene based on their 'depth' value, allowing them to move in front or behind other Game Objects. In some game frameworks this is known as the 'z-index'."}),"\n",(0,a.jsx)(n.p,{children:"When a Scene Camera is preparing to render each frame, it will sort all the renderable Game Objects in the Scene based on their depth value. Those with the lowest depth values are rendered first, with the Game Objects with the highest depth values being rendered last, or 'on top' of the earlier ones."}),"\n",(0,a.jsx)(n.p,{children:"By default, all Game Objects are given a depth value of zero, meaning they are all sorted based on their creation order, and placement in the Display List. The Depth Component allows you to override this."}),"\n",(0,a.jsxs)(n.p,{children:["The current depth of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"depth"})," numeric property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const depth = sprite.depth;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can set the depth of a Game Object using the chainable ",(0,a.jsx)(n.code,{children:"setDepth"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setDepth(value);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can modify the ",(0,a.jsx)(n.code,{children:"depth"})," property directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.depth = value;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The value can be any number, either an integer or a float. The default value is zero."}),"\n",(0,a.jsx)(n.p,{children:"There is no upper or lower bounds on what the value can be and the numbers do not have to be assigned consecutively. If it's easier for you to give a Game Object a depth of 1000, and another a depth of 500, then you're free to do so."}),"\n",(0,a.jsxs)(n.p,{children:["You can also bind the depth property to a Game Objects position. For example, it's quite common to bind the depth of a Game Object to its ",(0,a.jsx)(n.code,{children:"y"})," position, so that the higher it is in the Scene, the higher its depth value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"update ()\n{\n    sprite.setDepth(sprite.y);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["If one or more Game Objects share the same ",(0,a.jsx)(n.code,{children:"depth"})," value, then they are sorted based on their index within the Display List. The first one in the list is rendered first, and so on."]}),"\n",(0,a.jsx)(n.h3,{id:"depth-updates",children:"Depth Updates"}),"\n",(0,a.jsxs)(n.p,{children:["When the ",(0,a.jsx)(n.code,{children:"depth"})," property of any Game Object is modified, the Depth Component tells the Scene that it needs to run a depth sort on the Display List. This is done by the component calling the ",(0,a.jsx)(n.code,{children:"DisplayList.queueDepthSort"})," method and it happens automatically, you don't need to do anything else."]}),"\n",(0,a.jsx)(n.p,{children:"Because sorting the rendering list can be a costly operation if there are a lot of Game Objects, Phaser will queue the depth sort and only execute it at render time. If no Game Objects have had their depth changed since the last frame, the depth sort is skipped entirely."}),"\n",(0,a.jsx)(n.p,{children:"Creating new Game Objects, or removing existing ones, will also cause the depth sort to be queued."}),"\n",(0,a.jsx)(n.h3,{id:"depth-and-containers",children:"Depth and Containers"}),"\n",(0,a.jsx)(n.p,{children:"Container Game Objects can have their depth property set just like any other Game Object and it will influence at which point they are rendered. However, when a child is placed inside a Container, its own depth value is ignored. Instead, the depth of the Container is used by all children and cannot be overidden."}),"\n",(0,a.jsxs)(n.p,{children:["If you wish to adjust the order of children within a Container, there are specific methods available to do this, such as ",(0,a.jsx)(n.code,{children:"moveUp"}),", ",(0,a.jsx)(n.code,{children:"moveDown"}),", ",(0,a.jsx)(n.code,{children:"sendToBack"})," and so on. See the Container documentation for more details."]}),"\n",(0,a.jsx)(n.h2,{id:"flip-component",children:"Flip Component"}),"\n",(0,a.jsx)(n.p,{children:"The Flip Component allows for texture-based Game Objects to 'flip' themselves either horizontally, vertically or both. As the name implies, this means the texture being displayed by the Game Object is inverted on the respective axis."}),"\n",(0,a.jsxs)(n.p,{children:["The current flip of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"flipX"})," and ",(0,a.jsx)(n.code,{children:"flipY"})," boolean properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const flipX = player.flipX;\nconst flipY = player.flipY;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the flipped state of a Game Object you can use the chainable ",(0,a.jsx)(n.code,{children:"setFlip"}),", ",(0,a.jsx)(n.code,{children:"setFlipX"})," and ",(0,a.jsx)(n.code,{children:"setFlipY"})," methods:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setFlip(x, y);\nplayer.setFlipX(x);\nplayer.setFlipY(y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"flipX"})," and ",(0,a.jsx)(n.code,{children:"flipY"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.flipX = true;\nplayer.flipY = false;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"toggle-and-reset-a-flip",children:"Toggle and Reset a Flip"}),"\n",(0,a.jsx)(n.p,{children:"There are two helper methods available which will toggle the current flipX or flipY state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.toggleFlipX();\nplayer.toggleFlipY();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can reset the flipped state of a Game Object by calling the ",(0,a.jsx)(n.code,{children:"resetFlip"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.resetFlip();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"flip-vs-scale",children:"Flip vs. Scale"}),"\n",(0,a.jsx)(n.p,{children:"As you may have read in the Scale section of the guide, you can achieve the same visual effect as Flip by setting the scale to a negative value."}),"\n",(0,a.jsx)(n.p,{children:"However, flip works independently of scale and is set as a boolean, not a ratio. This allows you to flip a Game Object based on an event, such as a patrolling enemy reaching a wall, irrespective of its scale value."}),"\n",(0,a.jsx)(n.p,{children:"Game Objects always flip based on the center of their texture frame. You cannot set the origin of a flip."}),"\n",(0,a.jsx)(n.h2,{id:"mask-component",children:"Mask Component"}),"\n",(0,a.jsx)(n.p,{children:"The Mask Component allows you to set if a Game Object should be 'masked' during rendering. A mask controls which pixels of the Game Object are visible during rendering. Anything outside of the mask is not rendered. In Phaser there are two types of mask: a Bitmap Mask and a Geometry Mask."}),"\n",(0,a.jsxs)(n.p,{children:["The current mask of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"mask"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const mask = sprite.mask;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can set the mask of a Game Object using the chainable ",(0,a.jsx)(n.code,{children:"setMask"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setMask(mask);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"mask"})," property directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.mask = mask;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To remove a mask, you can either call the chainable ",(0,a.jsx)(n.code,{children:"clearMask"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.clearMask();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, set the ",(0,a.jsx)(n.code,{children:"mask"})," property to ",(0,a.jsx)(n.code,{children:"null"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.mask = null;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When using the ",(0,a.jsx)(n.code,{children:"clearMask"})," method you also have the option of destroying the mask currently attached to the Gamne Object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.clearMask(true);\n"})}),"\n",(0,a.jsx)(n.h3,{id:"how-masks-work-in-phaser",children:"How Masks Work in Phaser"}),"\n",(0,a.jsx)(n.p,{children:"There are two types of mask in Phaser, which we will cover in the next two sections. Although they offer different features they are both created and applied in the same way."}),"\n",(0,a.jsx)(n.p,{children:"Masks are global objects. They are not bound to, or belong to any one single Game Object. You can, and often should, use the same mask on as many different Game Objects as you like, at the same time."}),"\n",(0,a.jsx)(n.p,{children:"Masks are created and positioned in world space only. They are not applied relative to the Game Object they are masking. For example, if you create a mask positioned at world coordinates 200x300, then it will be positioned at 200x300 regardless of where the Game Object it is masking is."}),"\n",(0,a.jsx)(n.p,{children:"Masks themselves are not Game Objects, they do not live on the display list and cannot be modified like a Game Object, i.e. you cannot set their rotation or scale as you would a Sprite. That does not mean you cannot modify a mask post-creation, it simply means that mask objects do not have a Transform component."}),"\n",(0,a.jsx)(n.h3,{id:"geometry-mask",children:"Geometry Mask"}),"\n",(0,a.jsx)(n.p,{children:"A Geometry Mask is a special type of mask that uses the path information from a Graphics Game Object in order to define its shape."}),"\n",(0,a.jsx)(n.p,{children:"With the Canvas Renderer it uses the 'clipping path' feature of the Canvas API. The WebGL Renderer uses a built-in WebGL feature called the Stencil Buffer."}),"\n",(0,a.jsxs)(n.p,{children:["It's called a Geometry Mask because it uses geometric data in order to create itself. Graphics Game Objects have lots of features available for generating these paths, including ",(0,a.jsx)(n.code,{children:"lineTo"}),", ",(0,a.jsx)(n.code,{children:"arc"}),", ",(0,a.jsx)(n.code,{children:"ellipse"})," and more. Please see the Graphics Game Object documentation for more details."]}),"\n",(0,a.jsx)(n.p,{children:"Because it uses path data for the mask it means you cannot do 'per pixel' masking with this type of mask. It's not suitable for creating a mask from a sprite with a gradient texture, for example. For that you should use a Bitmap Mask instead."}),"\n",(0,a.jsxs)(n.p,{children:["Geometry Masks have the ability to set their ",(0,a.jsx)(n.code,{children:"invertAlpha"})," boolean properties. This is a WebGL only feature and allows you to 'invert' which area of the mask is applied, or not."]}),"\n",(0,a.jsx)(n.h3,{id:"bitmap-mask",children:"Bitmap Mask"}),"\n",(0,a.jsx)(n.p,{children:"A Bitmap Mask uses a texture in order to control which pixels will be 'masked out' of the target Game Object during rendering. In order to achieve this it uses a special internal pipeline called the BitmapMask Pipeline. Because of this, it only works with the WebGL Renderer."}),"\n",(0,a.jsx)(n.p,{children:"As it uses a texture for the shader input it means you can mask things on a per-pixel level, something not possible with the Geometry Mask. The source of the Bitmap Mask can be either a texture-based Game Object, such as a Sprite, or a Dynamic Texture instance."}),"\n",(0,a.jsx)(n.p,{children:"The Bitmap Mask shader works by taking the alpha level from the mask texture and the alpha level of the masked Game Object and calculating the final resulting alpha level from the two, per pixel. It does not matter what color the mask texture is drawn in, all it looks at is the alpha value of each pixel. For example, if the mask has an alpha value of 0.95 for a specific pixel, and the Game Object texture has an alpha of 0.5 for the same pixel, the final alpha value when rendered will be 0.45. Naturally, the lower the resulting alpha value, the less the Game Object will be visible through it."}),"\n",(0,a.jsxs)(n.p,{children:["Bitmap Masks have the ability to set their ",(0,a.jsx)(n.code,{children:"invertAlpha"})," boolean properties. This allows you to invert the alpha comparison, so that a low alpha value in the mask texture results in a high alpha value in the masked Game Object, and vice versa."]}),"\n",(0,a.jsx)(n.p,{children:"Note that you cannot set a Bitmap Mask and a Blend Mode on a single Game Object."}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When using Geometry Masks you should keep in mind the complexity of the path, i.e. how many points it has in it. The more complex the path, the longer it will take both Canvas and WebGL to render the masked Game Objects."}),"\n",(0,a.jsx)(n.p,{children:"When using Bitmap Masks you should keep in mind the size of the masked texture. The larger it is, the more pixels have to be passed through the mask shader and the more GPU power will be required to render the masked Game Objects."}),"\n",(0,a.jsx)(n.p,{children:"With both types of mask, the renderer needs to perform a lot of additional calculations to handle the masking. This includes breaking the batch in WebGL, enabling the stencil functions or mask shader and then rendering the masked Game Objects. For this reason you should never apply a mask to a Game Object that doesn't yet require it."}),"\n",(0,a.jsx)(n.p,{children:"Masks are, however, batched. This means if you have a group of masked Game Objects in sequence in the Display List, all sharing the same mask, then you will only pay the cost of establishing that mask once."}),"\n",(0,a.jsx)(n.h2,{id:"origin-component",children:"Origin Component"}),"\n",(0,a.jsxs)(n.p,{children:["By default most Game Objects are ",(0,a.jsx)(n.em,{children:"centered"})," on their ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," coordinates. This means that if you create a Sprite at the coordinates 300x200, then the ",(0,a.jsx)(n.em,{children:"center"})," of the Sprite will be placed at 300x200."]}),"\n",(0,a.jsx)(n.p,{children:"In some game frameworks the default origin is the top-left, and in others the bottom-left. It is also sometimes known as the 'anchor point' or 'pivot point'. However, in Phaser it's called the origin and it defaults to the center. You can change this via the methods available from the Origin Component."}),"\n",(0,a.jsxs)(n.p,{children:["The current origin of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"originX"})," and ",(0,a.jsx)(n.code,{children:"originY"})," numeric properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const originX = player.originX;\nconst originY = player.originY;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the origin of a Game Object you can use the chainable ",(0,a.jsx)(n.code,{children:"setOrigin"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setOrigin(x, y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"originX"})," and ",(0,a.jsx)(n.code,{children:"originY"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.originX = 0.5;\nplayer.originY = 0.5;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The values are given as a normalized value between 0 and 1. For example, setting the origin to 0.5 means it will be placed exactly in the center of the Game Object, no matter what its dimensions. A value of 0 would be the top-left of the Game Object, and 1 would be the bottom-right."}),"\n",(0,a.jsx)(n.p,{children:"The origin controls both the placement of the Game Object and also the point around which it rotates. If you wanted to rotate a Game Object around its top-left corner, you would set its origin to be 0x0."}),"\n",(0,a.jsx)(n.p,{children:"Or, if you wanted to position a Game Object in the bottom-right of the screen, and the screen was 800x600 in size, you could set the origin to be 1x1 and its position to be 800x600."}),"\n",(0,a.jsx)(n.p,{children:"Game Objects can only have one origin. For example, they do not have a unique origin for rotation and another for position, or scale. If you need to emulate this behavior, you can create use a Container Game Object and then add your other Game Objects to it."}),"\n",(0,a.jsx)(n.h3,{id:"the-display-origin",children:"The Display Origin"}),"\n",(0,a.jsx)(n.p,{children:"Phaser also offers what is known as the Display Origin. This is a way to set the origin of a Game Object using pixel values instead of normalized ones. The range of the values is between 0 and the base width or height of the Game Object."}),"\n",(0,a.jsxs)(n.p,{children:["To set the display origin of a Game Object you can use the chainable ",(0,a.jsx)(n.code,{children:"setDisplayOrigin"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setDisplayOrigin(x, y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"displayOriginX"})," and ",(0,a.jsx)(n.code,{children:"displayOriginY"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.displayOriginX = 256;\nplayer.displayOriginY = 128;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"custom-frame-pivot",children:"Custom Frame Pivot"}),"\n",(0,a.jsxs)(n.p,{children:["Some software, such as Texture Packer, allows you to define a specific 'pivot point' for a texture frame. This is then exported in the JSON data that Texture Packer creates. Phaser will look for these custom pivot points and then set the origin of the Game Object to match it. This is done via the method ",(0,a.jsx)(n.code,{children:"setOriginFromFrame"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setOriginFromFrame();\n"})}),"\n",(0,a.jsx)(n.p,{children:"This is called automatically if you create a Sprite and provide it with a texture frame that has a custom pivot point in the data. But you can also call it directly, if you need to."}),"\n",(0,a.jsx)(n.h2,{id:"pipeline-component",children:"Pipeline Component"}),"\n",(0,a.jsx)(n.p,{children:"The Pipeline Component controls which rendering pipeline the Game Object uses to render with. This is only set if the Phaser Game is using the WebGL Renderer. The Canvas Renderer does not use custom pipelines."}),"\n",(0,a.jsx)(n.p,{children:"A Pipeline is an internal term and class construct that Phaser uses to handle rendering different types of Game Object. For example, there is the Multi Pipeline, which Sprites use, a Rope Pipeline for the Rope Game Object, and so on. You can also create your own custom pipelines, which can give you a lot of flexibility and power when it comes to rendering. The Pipeline Component is how you set a pipeline on a Game Object."}),"\n",(0,a.jsxs)(n.p,{children:["The current pipeline of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"pipeline"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const pipeline = sprite.pipeline;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This will be ",(0,a.jsx)(n.code,{children:"null"})," by default. It is not set until the Game Object is instantiated. As part of that process, all Game Objects call the ",(0,a.jsx)(n.code,{children:"initPipeline"})," method, which is responsible for setting the default pipeline the Game Object uses. This is an internal method and should not be called directly."]}),"\n",(0,a.jsxs)(n.p,{children:["You can set the pipeline of a Game Object using the chainable ",(0,a.jsx)(n.code,{children:"setPipeline"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setPipeline(pipeline);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"pipeline"})," property directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.pipeline = pipeline;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["When using the ",(0,a.jsx)(n.code,{children:"setPipeline"})," method you can pass either a string, or an instance of a ",(0,a.jsx)(n.code,{children:"WebGLPipeline"})," to the method. Regardless of which you pass, it will look-up the pipeline in the Pipeline Manager and if found it will be set on the Game Object. If you pass a string that doesn't match any pipeline, it will be ignored. If you pass a pipeline that isn't found in the Pipeline Manager, it will be ignored."]}),"\n",(0,a.jsxs)(n.p,{children:["To remove a pipeline, you can either call the chainable ",(0,a.jsx)(n.code,{children:"resetPipeline"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.resetPipeline();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, set the ",(0,a.jsx)(n.code,{children:"pipeline"})," property to match the ",(0,a.jsx)(n.code,{children:"defaultPipeline"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.pipeline = sprite.defaultPipeline;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"defaultPipeline"})," property is set when the Game Object is first created and should be treated as read-only."]}),"\n",(0,a.jsxs)(n.p,{children:["If you wish to get the string-based name of the pipeline the Game Object is using, you can call the ",(0,a.jsx)(n.code,{children:"getPipelineName"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const name = sprite.getPipelineName();\n"})}),"\n",(0,a.jsx)(n.h3,{id:"pipeline-data",children:"Pipeline Data"}),"\n",(0,a.jsxs)(n.p,{children:["The Pipeline Component also has a ",(0,a.jsx)(n.code,{children:"pipelineData"})," property, which is an object that contains data that the pipeline may need during rendering. You can set a key-value object to be used as the pipeline data by passing it to the ",(0,a.jsx)(n.code,{children:"setPipeline"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setPipeline(pipeline, { foo: 1, bar: 2 });\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can call the ",(0,a.jsx)(n.code,{children:"setPipelineData"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"sprite.setPipelineData('key', value);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Pipeline data is not used by any of the default pipelines in Phaser, but is made available for your own custom pipelines. For example, if you wanted to create a pipeline that colored Game Objects in a special way, you could store the color of the Game Object in the pipeline data, ready for it to read prior to rendering."}),"\n",(0,a.jsx)(n.p,{children:"Creating custom pipelines is an advanced feature of Phaser and requires a good understanding of WebGL and GLSL shaders. It will be covered elsewhere in this guide."}),"\n",(0,a.jsx)(n.h2,{id:"scroll-factor-component",children:"Scroll Factor Component"}),"\n",(0,a.jsx)(n.p,{children:'The Scroll Factor Component allows you to control the scroll factor of a Game Object. The "scroll factor" is how much influence a camera will exert upon a Game Object as the camera scrolls around the game world.'}),"\n",(0,a.jsx)(n.p,{children:"As covered in the Transform section, Game Objects have a position within the world. This position is combined with the Scene camera and used to calculate where the Game Object should be rendered on-screen. If the camera is moving around the world, the Game Object will appear to move with it, even though its position hasn't changed, simply by virtue of the fact that the camera is now looking at another part of the world."}),"\n",(0,a.jsx)(n.p,{children:"The scroll factor allows you to modify the relationship between the Game Objects position and how the Camera projects it. Setting a scroll factor never changes the position of the Game Object, or any related physics bodies, it just changes where they are rendered by the camera."}),"\n",(0,a.jsxs)(n.p,{children:["The current scroll factor of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"scrollFactorX"})," and ",(0,a.jsx)(n.code,{children:"scrollFactorY"})," numeric properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scrollFactorX = player.scrollFactorX;\nconst scrollFactorY = player.scrollFactorY;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the scroll factor of a Game Object you can use the chainable ",(0,a.jsx)(n.code,{children:"setScrollFactor"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setScrollFactor(x, y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"scrollFactorX"})," and ",(0,a.jsx)(n.code,{children:"scrollFactorY"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.scrollFactorX = 0.5;\nplayer.scrollFactorY = 0.5;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The default value for each axis is 1. This means as the camera scrolls, the Game Object will appear to move at the exact same rate."}),"\n",(0,a.jsx)(n.p,{children:"A value of zero will stop the Game Object from being influenced by the camera. This will effectively 'lock' it in place on the screen. This can be useful if you wish to create a UI or other interface element that remains in the same place regardless of where the camera is looking."}),"\n",(0,a.jsx)(n.p,{children:"A value of 0.5 will make the Game Object move at half the rate of the camera. The scroll factor can be any value from zero and above, although realistically you would likely clamp it to a value between 0 and 1."}),"\n",(0,a.jsx)(n.h2,{id:"size-component",children:"Size Component"}),"\n",(0,a.jsx)(n.p,{children:"The Size Component is responsible for managing both the base and display size of a Game Object."}),"\n",(0,a.jsx)(n.p,{children:"Most Game Objects have an instrinsic, or base size. For texture-based Game Objects, such as Sprites, the size is set automatically to match the size of the texture frame the Sprite is using. When the frame changes, the size is updated automatically. Some Game Objects have a size that you specify upon creation, such as the Tile Sprite."}),"\n",(0,a.jsxs)(n.p,{children:["It is very rare for you to need to change the base size of a Game Object. However, there are some Game Objects, such as Containers, which do not have a base size. In these cases, the ",(0,a.jsx)(n.code,{children:"setSize"})," method is used to set the size of the Game Object."]}),"\n",(0,a.jsxs)(n.p,{children:["The current base size of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"width"})," and ",(0,a.jsx)(n.code,{children:"height"})," numeric properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const width = player.width;\nconst height = player.height;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the size you can use the chainable ",(0,a.jsx)(n.code,{children:"setSize"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setSize(width, height);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"width"})," and ",(0,a.jsx)(n.code,{children:"height"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.width = 128;\nplayer.height = 128;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The size is used in lots of internal places, from creating input hit areas, to physics bodies, to calculating the bounds of a Game Object. As mentioned, it's not common to adjust it, however the properties are public should you need to. Just be aware it may have unintended consequences."}),"\n",(0,a.jsx)(n.h3,{id:"display-size",children:"Display Size"}),"\n",(0,a.jsx)(n.p,{children:"Unlike the Game Object's size, its Display Size was created specifically for you to modify  as needed."}),"\n",(0,a.jsx)(n.p,{children:"The Display Size is, for a texture-based Game Object, its frame size multiplied by its local scale. For example, if a Sprite has a 128x128 texture frame set and a scale of 2.0, then its display width and height would be 256x256."}),"\n",(0,a.jsxs)(n.p,{children:["The current display size of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"displayWidth"})," and ",(0,a.jsx)(n.code,{children:"displayHeight"})," numeric properties:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const width = player.displayWidth;\nconst height = player.displayHeight;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the size you can use the chainable ",(0,a.jsx)(n.code,{children:"setDisplaySize"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setDisplaySize(width, height);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"displayWidth"})," and ",(0,a.jsx)(n.code,{children:"displayHeight"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.displayWidth = 128;\nplayer.displayHeight = 128;\n"})}),"\n",(0,a.jsx)(n.p,{children:"The values are given in pixels."}),"\n",(0,a.jsxs)(n.p,{children:["Setting these values, either directly or via the method, will adjust the local ",(0,a.jsx)(n.em,{children:"scale"})," of the Game Object. It provides a way for you to set the size in pixels that you wish the Game Object to be displayed at, rather than as a scale ratio."]}),"\n",(0,a.jsx)(n.h3,{id:"parent-size",children:"Parent Size"}),"\n",(0,a.jsxs)(n.p,{children:["A Game Object Container has no size by default. You can set its size via the ",(0,a.jsx)(n.code,{children:"setSize"})," method, but it will only impact the Container itself, not any of its children. If you wish to set the size of the Container and all children, you should scale it instead."]}),"\n",(0,a.jsx)(n.p,{children:"If a Game Object has a parent Container then the display size of the parent is automatically factored in to the Game Object's size. For example, if you have a Sprite that is 128x128 in size, but its parent Container has a scale of 0.5, then the Sprite will be displayed at 64x64 pixels. This is because it's scaled by the Container."}),"\n",(0,a.jsx)(n.p,{children:"If you set the display width or height of a Game Object to zero, it will be skipped for rendering. This is because the Game Object has no dimensions, so it cannot be seen. Therefore, to optimize the rendering pass, Phaser will skip it entirely."}),"\n",(0,a.jsx)(n.h2,{id:"transform-component",children:"Transform Component"}),"\n",(0,a.jsx)(n.p,{children:"The Transform Component is responsible for managing the position, scale and rotation of a Game Object."}),"\n",(0,a.jsxs)(n.p,{children:["Most Game Objects have this component, but you can test for it programatically by checking if the ",(0,a.jsx)(n.code,{children:"hasTransformComponent"})," property exists and is ",(0,a.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"if (player.hasTransformComponent)\n{\n    //  This Game Object has a Transform Component\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"position",children:"Position"}),"\n",(0,a.jsxs)(n.p,{children:["The current local position of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," properties."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const x = player.x;\nconst y = player.y;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can set the position using the chainable ",(0,a.jsx)(n.code,{children:"setPosition"}),", ",(0,a.jsx)(n.code,{children:"setX"})," and ",(0,a.jsx)(n.code,{children:"setY"})," methods:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setPosition(x, y);\nplayer.setX(x);\nplayer.setY(y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.x = x;\nplayer.y = y;\n"})}),"\n",(0,a.jsx)(n.p,{children:"They can be either negative or positive values, and whole numbers or floats."}),"\n",(0,a.jsx)(n.p,{children:"The position of a Game Object is always relative to its parent Container, if it has one. If it doesn't have a parent, then the position is its location within the Game World."}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setPosition(300, 200);\nchild.setPosition(100, 100);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the code above, the Container is positioned at 300 x 200 in the game world. The child of the Container is positioned at 100 x 100. This means that the child will appear at 400 x 300 in the game world, because its position is relative to the Container."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setPosition(300, 200);\nchild.setPosition(-100, -100);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this code, the child will appear at 200 x 100 in the game world, because it has a negative position, relative to its parent."}),"\n",(0,a.jsx)(n.p,{children:"The position is always set and returned as a number. This allows you to use the position directly in further calculations, or manipulate it as you would any other number:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"enemy.x = player.x;\nenemy.y = player.y - 100;\n"})}),"\n",(0,a.jsx)(n.p,{children:"See the Origin Component to learn how Phaser knows which point of the Game Object to use as its x/y anchor."}),"\n",(0,a.jsxs)(n.p,{children:["Phaser also has two additional position related properties: ",(0,a.jsx)(n.code,{children:"z"})," and ",(0,a.jsx)(n.code,{children:"w"}),". You can set these optional values when calling ",(0,a.jsx)(n.code,{children:"setPosition"}),", or they have their own chainable methods ",(0,a.jsx)(n.code,{children:"setZ"})," and ",(0,a.jsx)(n.code,{children:"setW"}),". These properties are not typically used internally by Phaser, but are made available should you require them for more advanced position, such as depth sorting."]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"copyPosition"})," method allows you to copy a Game Objects position directly to another object:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"enemy.copyPosition(player);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The target object can be any object that has public ",(0,a.jsx)(n.code,{children:"x"})," and ",(0,a.jsx)(n.code,{children:"y"})," properties, such as another Game Object, or a Vector2."]}),"\n",(0,a.jsxs)(n.p,{children:["You can also set the Game Object to have a random position with the ",(0,a.jsx)(n.code,{children:"setRandomPosition"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"enemy.setRandomPosition();\n"})}),"\n",(0,a.jsx)(n.p,{children:"By default, if you don't provide any parameters, the Game Object will be given a position anywhere without the size set by the Scale Manager. However, you can also pass in x, y, width and height parameters to the method, to control a rectangle in which the random position will be set:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"enemy.setRandomPosition(100, 100, 600, 400);\n"})}),"\n",(0,a.jsx)(n.p,{children:"The Geometry classes have a variety of similar methods, for positioning objects within geometric shapes, however this method is handy if you just want to quickly position an object anywhere on-screen."}),"\n",(0,a.jsx)(n.h3,{id:"scale",children:"Scale"}),"\n",(0,a.jsxs)(n.p,{children:["The current local scale of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"scaleX"})," and ",(0,a.jsx)(n.code,{children:"scaleY"})," properties."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const scaleX = player.scaleX;\nconst scaleY = player.scaleY;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can set the scale using the chainable ",(0,a.jsx)(n.code,{children:"setScale"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setScale(x, y);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"scaleX"})," and ",(0,a.jsx)(n.code,{children:"scaleY"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.scaleX = x;\nplayer.scaleY = y;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["There is also a special property called ",(0,a.jsx)(n.code,{children:"scale"})," which allows you to set both the x and y scale at the same time, to the same value:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.scale = 2;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Scale values can be either negative or positive, and whole numbers or floats."}),"\n",(0,a.jsx)(n.p,{children:"By default, Game Objects have a scale value of 1, meaning they will be rendered at the same size as their texture frame. By adjusting the scale properties you can make them appear bigger or smaller. The number you give is multiplied by their base size. For example, a scale value of 0.5 would halve the displayed size of the Game Object, where as a value of 2 would double it."}),"\n",(0,a.jsx)(n.p,{children:"Setting a scale does not change the actual underlying size of the Game Object. If you were to read the width or height of a Game Object after adjusting its scale, the returned values would be the un-scaled original sizes. You can read more about this in the Size Component section."}),"\n",(0,a.jsx)(n.p,{children:"The scale is always set and returned as a number. This allows you to use the scale directly in further calculations, or manipulate it as you would any other number."}),"\n",(0,a.jsx)(n.p,{children:"Scaling always takes place around the center of the Game Object, regardless of the Game Objects origin, and cannot be changed."}),"\n",(0,a.jsx)(n.p,{children:"The scale of a Game Object is always relative to its parent Container, if it has one."}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setScale(2, 2);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the code above, the Container is scaled by 2 on each axis, meaning and all of its children will be doubled in size."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setScale(2, 2);\nchild.setScale(2, 2);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this code, the child will appear at 4x the size of the container, because it has been scaled twice itself and also inherits the double scale from its parent."}),"\n",(0,a.jsx)(n.p,{children:"If you scale any axis of a Game Object to zero, it will be skipped for rendering. This is because a Game Object with a scale of zero has no dimensions, so it cannot be seen. Therefore, to optimize the rendering pass, Phaser will skip those Game Objects entirely."}),"\n",(0,a.jsx)(n.p,{children:"If you scale a Game Object negatively, an interesting effect happens. The Game Object will appear flipped. For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.scaleX = -1;\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will render the Game Object as if it was flipped horizontally. This is handy for characters that need to face in two directions but you only need to store the textures drawn in one direction, using the negative scale them to render the opposites at run-time. Note that Phaser also has a 'Flip Component' that can be used to flip a Game Object without adjusting its scale."}),"\n",(0,a.jsx)(n.p,{children:"When you scale a texture based Game Object it's important to understand that the renderer will need to 'guess' at any pixels that are now present because of the increased size of the Game Object. For example, if you have a 16x16 texture and you scale it by 4, it will appear as 64x64 on screen. All of those extra pixels that didn't exist before in the original texture are created by the GPU during the rendering process. A similar thing happens if you scale a texture down. The GPU has to decide which pixels to not display and tries to create an average that best represents the orignal image."}),"\n",(0,a.jsx)(n.p,{children:"Lots of art software, like Photoshop, have the ability to apply special filters and effects when resizing images to create more refined results. However, WebGL and Canvas don't have this feature and they tend to favor speed over visual fidelity. After all, unlike Photoshop, they have to do this 60 times a second, or more. If you see a drop in visual quality worse than you were expecting, then you should consider using a smaller, or larger, texture that was pre-scaled in an art package instead."}),"\n",(0,a.jsx)(n.h3,{id:"rotation",children:"Rotation"}),"\n",(0,a.jsxs)(n.p,{children:["The current local rotation of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"rotation"})," property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const rotation = player.rotation;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"rotation"})," value is always in radians. If you prefer to work with degrees, you can use the ",(0,a.jsx)(n.code,{children:"angle"})," property instead:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const angle = player.angle;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the rotation, or angle, you can use the chainable ",(0,a.jsx)(n.code,{children:"setRotation"})," and ",(0,a.jsx)(n.code,{children:"setAngle"})," methods:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setRotation(rotation);\nplayer.setAngle(angle);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"rotation"})," and ",(0,a.jsx)(n.code,{children:"angle"})," properties directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.rotation = rotation;\nplayer.angle = angle;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Phaser uses a right-handed coordinate system, where 0 is East, to the right, and 3.14 (or 180 degrees) is West, to the left. South is 1.57, or 90 degrees and North is -1.57 (or -90 degrees). If you visualise the rotation as a circle, the bottom half is positive and the top-half is negative. This is the same as Adobe Flash, from which the first version of Phaser took its inspiration."}),"\n",(0,a.jsx)(n.p,{children:"Rotation in Phaser always takes place around the origin of the Game Object. Which means by default Game Objects typically rotate around their center. As you've read, you can adjust the origin. This changes where both the position and rotation occurs. You cannot change the rotation point of a Game Object, only its origin."}),"\n",(0,a.jsx)(n.p,{children:"The rotation of a Game Object is always relative to its parent Container, if it has one."}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setRotation(0.75);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In the code above, the Container is rotated by 0.75 radians, meaning all of its children will be rotated by the same amount."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"container.setRotation(0.75);\nchild.setRotation(0.75);\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this code, the child will be rotated by 1.5 radians in total, because it inherits the rotation from its parent, then adds its own."}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"rotation"})," property only contains the local rotation value. If you wish to get the sum rotation of the Game Object taking into account all of its ancestors, you can use the ",(0,a.jsx)(n.code,{children:"getParentRotation"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const rotation = player.getParentRotation();\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will return the total rotation of all parent Containers, in radians. If you need the world rotation, then add the Game Objects rotation to the final value:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const rotation = player.getParentRotation() + player.rotation;\n"})}),"\n",(0,a.jsx)(n.h3,{id:"local-and-world-transforms",children:"Local and World Transforms"}),"\n",(0,a.jsx)(n.p,{children:"The Transform Component has a couple of methods that allow you to return a Transform Matrix instance that has been set to be either the local or world transform for the Game Object."}),"\n",(0,a.jsx)(n.p,{children:"A Transform Matrix is a 3x3 identity matrix use for perform affine transformations. In Phaser, the operations are performed in the order of Translation, Rotation and then Scale, always in that order."}),"\n",(0,a.jsxs)(n.p,{children:["The method ",(0,a.jsx)(n.code,{children:"getLocalTransformMatrix"})," will return a purely local Transform Matrix:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const matrix = player.getLocalTransformMatrix();\n"})}),"\n",(0,a.jsx)(n.p,{children:"This matrix will not include any transforms from parent Containers. It will only contain the transforms of the Game Object itself."}),"\n",(0,a.jsxs)(n.p,{children:["The method ",(0,a.jsx)(n.code,{children:"getWorldTransformMatrix"})," will return a Transform Matrix that contains the Game Objects local transforms, multiplied with those of all of its parent Containers:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const matrix = player.getWorldTransformMatrix();\n"})}),"\n",(0,a.jsx)(n.p,{children:"Both methods have the option to be passed Transform Matrix instances. If given, the values will be set in those, instead of a new instance being created and returned. If you are calling either of these methods a lot, i.e. in a constant update loop, or en-masse, then you should create some temporary matrices to pass to them, to avoid the constant creation of new objects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const tempMatrix = new Phaser.GameObjects.Components.TransformMatrix();\n\nplayer.getLocalTransformMatrix(tempMatrix);\n"})}),"\n",(0,a.jsx)(n.p,{children:"Or:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const tempMatrix = new Phaser.GameObjects.Components.TransformMatrix();\nconst tempParentMatrix = new Phaser.GameObjects.Components.TransformMatrix();\n\nplayer.getWorldTransformMatrix(tempMatrix, tempParentMatrix);\n"})}),"\n",(0,a.jsx)(n.h2,{id:"visible-component",children:"Visible Component"}),"\n",(0,a.jsx)(n.p,{children:"The Visible Component is responsible for setting the visible state of a Game Object."}),"\n",(0,a.jsxs)(n.p,{children:["A Game Object with a visible state of ",(0,a.jsx)(n.code,{children:"true"})," is rendered to the display, where-as one with a visible state of ",(0,a.jsx)(n.code,{children:"false"})," is not. By default, Game Objects have a visible state of ",(0,a.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The current local visible state of a Game Object is stored in its ",(0,a.jsx)(n.code,{children:"visible"})," boolean property:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"const visible = player.visible;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To set the visible state you can use the chainable ",(0,a.jsx)(n.code,{children:"setVisible"})," method:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.setVisible(visible);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Or, you can set the ",(0,a.jsx)(n.code,{children:"visible"})," boolean directly:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-js",children:"player.visible = false;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["By default, Game Objects will have a visible state of ",(0,a.jsx)(n.code,{children:"true"}),". This means they will be rendered."]}),"\n",(0,a.jsx)(n.p,{children:"Being able to toggle the visibility of a Game Object is very useful for quickly showing or hiding Game Objects, without impacting their positions or other properties."}),"\n",(0,a.jsx)(n.p,{children:"Hidden Game Objects are skipped by the renderer, saving cycle time, but still retain their internal position and state. This means that you can hide a Game Object, then make it visible again at a later stage, without having to reposition it or set other properties again."}),"\n",(0,a.jsx)(n.p,{children:"An invisible Game Object is still updated, however. For example, if you had an animated Sprite that was playing through an animation sequence, then setting it to be invisible would not cause the animation to pause as it would still be updating. The same goes for other actions, such as tweens, or physics collisions. The visible state is purely a rendering toggle."}),"\n",(0,a.jsx)(n.h3,{id:"parent-visibility",children:"Parent Visibility"}),"\n",(0,a.jsx)(n.p,{children:"If a Game Object has a parent Container, then the visible state of the parent will control if any of its children are rendered, or not. An invisible parent will skip rendering of all children, regardless of their own visible settings. However, if the parent is visible, then the childs visibliity will be used instead."})]})}function c(e={}){let{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:function(e,n,t){t.d(n,{R:()=>o,x:()=>r});var s=t(96540);let a={},i=s.createContext(a);function o(e){let n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);
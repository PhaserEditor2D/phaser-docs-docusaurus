"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["26409"],{94637:function(e,n,s){s.r(n),s.d(n,{metadata:()=>t,default:()=>o,frontMatter:()=>c,contentTitle:()=>d,toc:()=>h,assets:()=>l});var t=JSON.parse('{"id":"function/Phaser.Physics","title":"Phaser.Physics","description":"OverlapCirc","source":"@site/api-documentation_versioned_docs/version-3.85.2/function/Phaser.Physics.md","sourceDirName":"function","slug":"/function/physics","permalink":"/api-documentation/3.85.2/function/physics","draft":false,"unlisted":false,"tags":[],"version":"3.85.2","frontMatter":{"visibility":"public","slug":"physics","title":"Phaser.Physics","seoTitle":"Phaser.Physics","seoDescription":"Phaser v3.85.2 Documentation for Phaser.Physics","ogImage":null},"sidebar":"PhaserApiSidebar","previous":{"title":"Phaser.Math","permalink":"/api-documentation/3.85.2/function/math"},"next":{"title":"Phaser.Plugins","permalink":"/api-documentation/3.85.2/function/plugins"}}'),i=s(74848),r=s(28453);let c={visibility:"public",slug:"physics",title:"Phaser.Physics",seoTitle:"Phaser.Physics",seoDescription:"Phaser v3.85.2 Documentation for Phaser.Physics",ogImage:null},d="Phaser.Physics.Arcade.Components",l={},h=[{value:"OverlapCirc",id:"overlapcirc",level:2},{value:"&lt;static&gt; OverlapCirc(x, y, radius, [includeDynamic], [includeStatic])",id:"static-overlapcircx-y-radius-includedynamic-includestatic",level:3},{value:"OverlapRect",id:"overlaprect",level:2},{value:"&lt;static&gt; OverlapRect(x, y, width, height, [includeDynamic], [includeStatic])",id:"static-overlaprectx-y-width-height-includedynamic-includestatic",level:3},{value:"GetCollidesWith",id:"getcollideswith",level:2},{value:"&lt;static&gt; GetCollidesWith(categories)",id:"static-getcollideswithcategories",level:3},{value:"GetOverlapX",id:"getoverlapx",level:2},{value:"&lt;static&gt; GetOverlapX(body1, body2, overlapOnly, bias)",id:"static-getoverlapxbody1-body2-overlaponly-bias",level:3},{value:"GetOverlapY",id:"getoverlapy",level:2},{value:"&lt;static&gt; GetOverlapY(body1, body2, overlapOnly, bias)",id:"static-getoverlapybody1-body2-overlaponly-bias",level:3},{value:"SeparateX",id:"separatex",level:2},{value:"&lt;static&gt; SeparateX(body1, body2, overlapOnly, bias, [overlap])",id:"static-separatexbody1-body2-overlaponly-bias-overlap",level:3},{value:"SeparateY",id:"separatey",level:2},{value:"&lt;static&gt; SeparateY(body1, body2, overlapOnly, bias, [overlap])",id:"static-separateybody1-body2-overlaponly-bias-overlap",level:3},{value:"SetCollisionObject",id:"setcollisionobject",level:2},{value:"&lt;static&gt; SetCollisionObject(noneFlip, [data])",id:"static-setcollisionobjectnoneflip-data",level:3},{value:"Set",id:"set",level:2},{value:"&lt;static&gt; Set(b1, b2, ov)",id:"static-setb1-b2-ov",level:3},{value:"BlockCheck",id:"blockcheck",level:2},{value:"&lt;static&gt; BlockCheck()",id:"static-blockcheck",level:3},{value:"Check",id:"check",level:2},{value:"&lt;static&gt; Check()",id:"static-check",level:3},{value:"Run",id:"run",level:2},{value:"&lt;static&gt; Run(side)",id:"static-runside",level:3},{value:"RunImmovableBody1",id:"runimmovablebody1",level:2},{value:"&lt;static&gt; RunImmovableBody1(blockedState)",id:"static-runimmovablebody1blockedstate",level:3},{value:"RunImmovableBody2",id:"runimmovablebody2",level:2},{value:"&lt;static&gt; RunImmovableBody2(blockedState)",id:"static-runimmovablebody2blockedstate",level:3},{value:"Set",id:"set-1",level:2},{value:"&lt;static&gt; Set(b1, b2, ov)",id:"static-setb1-b2-ov-1",level:3},{value:"BlockCheck",id:"blockcheck-1",level:2},{value:"&lt;static&gt; BlockCheck()",id:"static-blockcheck-1",level:3},{value:"Check",id:"check-1",level:2},{value:"&lt;static&gt; Check()",id:"static-check-1",level:3},{value:"Run",id:"run-1",level:2},{value:"&lt;static&gt; Run(side)",id:"static-runside-1",level:3},{value:"RunImmovableBody1",id:"runimmovablebody1-1",level:2},{value:"&lt;static&gt; RunImmovableBody1(blockedState)",id:"static-runimmovablebody1blockedstate-1",level:3},{value:"RunImmovableBody2",id:"runimmovablebody2-1",level:2},{value:"&lt;static&gt; RunImmovableBody2(blockedState)",id:"static-runimmovablebody2blockedstate-1",level:3},{value:"ProcessTileCallbacks",id:"processtilecallbacks",level:2},{value:"&lt;static&gt; ProcessTileCallbacks(tile, sprite)",id:"static-processtilecallbackstile-sprite",level:3},{value:"ProcessTileSeparationX",id:"processtileseparationx",level:2},{value:"&lt;static&gt; ProcessTileSeparationX(body, x)",id:"static-processtileseparationxbody-x",level:3},{value:"ProcessTileSeparationY",id:"processtileseparationy",level:2},{value:"&lt;static&gt; ProcessTileSeparationY(body, y)",id:"static-processtileseparationybody-y",level:3},{value:"SeparateTile",id:"separatetile",level:2},{value:"&lt;static&gt; SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer)",id:"static-separatetilei-body-tile-tileworldrect-tilemaplayer-tilebias-islayer",level:3},{value:"TileCheckX",id:"tilecheckx",level:2},{value:"&lt;static&gt; TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer)",id:"static-tilecheckxbody-tile-tileleft-tileright-tilebias-islayer",level:3},{value:"TileCheckY",id:"tilechecky",level:2},{value:"&lt;static&gt; TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer)",id:"static-tilecheckybody-tile-tiletop-tilebottom-tilebias-islayer",level:3},{value:"TileIntersectsBody",id:"tileintersectsbody",level:2},{value:"&lt;static&gt; TileIntersectsBody(tileWorldRect, body)",id:"static-tileintersectsbodytileworldrect-body",level:3},{value:"MatterGameObject",id:"mattergameobject",level:2},{value:"&lt;static&gt; MatterGameObject(world, gameObject, [options], [addToWorld])",id:"static-mattergameobjectworld-gameobject-options-addtoworld",level:3},{value:"parseBody",id:"parsebody",level:2},{value:"&lt;static&gt; parseBody(x, y, config, [options])",id:"static-parsebodyx-y-config-options",level:3},{value:"parseFixture",id:"parsefixture",level:2},{value:"&lt;static&gt; parseFixture(fixtureConfig)",id:"static-parsefixturefixtureconfig",level:3},{value:"parseVertices",id:"parsevertices",level:2},{value:"&lt;static&gt; parseVertices(vertexSets, [options])",id:"static-parseverticesvertexsets-options",level:3},{value:"parseBody",id:"parsebody-1",level:2},{value:"&lt;static&gt; parseBody(x, y, config, [options])",id:"static-parsebodyx-y-config-options-1",level:3}];function a(e){let n={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"phaserphysicsarcadecomponents",children:"Phaser.Physics.Arcade.Components"})}),"\n",(0,i.jsx)(n.h2,{id:"overlapcirc",children:"OverlapCirc"}),"\n",(0,i.jsx)(n.h3,{id:"static-overlapcircx-y-radius-includedynamic-includestatic",children:"<static> OverlapCirc(x, y, radius, [includeDynamic], [includeStatic])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This method will search the given circular area and return an array of all physics bodies that\noverlap with it. It can return either Dynamic, Static bodies or a mixture of both."}),"\n",(0,i.jsx)(n.p,{children:"A body only has to intersect with the search area to be considered, it doesn't have to be fully\ncontained within it."}),"\n",(0,i.jsx)(n.p,{children:"If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,\notherwise the search is O(N) for Dynamic Bodies."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"default"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The x coordinate of the center of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The y coordinate of the center of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"radius"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The radius of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"includeDynamic"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"Should the search include Dynamic Bodies?"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"includeStatic"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Should the search include Static Bodies?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Array.<",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),">, Array.<",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),"> - An array of bodies that overlap with the given area."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/components/OverlapCirc.js#L6",children:"src/physics/arcade/components/OverlapCirc.js#L6"}),(0,i.jsx)(n.br,{}),"\nSince: 3.21.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"overlaprect",children:"OverlapRect"}),"\n",(0,i.jsx)(n.h3,{id:"static-overlaprectx-y-width-height-includedynamic-includestatic",children:"<static> OverlapRect(x, y, width, height, [includeDynamic], [includeStatic])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This method will search the given rectangular area and return an array of all physics bodies that\noverlap with it. It can return either Dynamic, Static bodies or a mixture of both."}),"\n",(0,i.jsx)(n.p,{children:"A body only has to intersect with the search area to be considered, it doesn't have to be fully\ncontained within it."}),"\n",(0,i.jsx)(n.p,{children:"If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\notherwise the search is O(N) for Dynamic Bodies."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"default"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The top-left x coordinate of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The top-left y coordinate of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"width"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The width of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"height"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The height of the area to search within."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"includeDynamic"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"Should the search include Dynamic Bodies?"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"includeStatic"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"false"}),(0,i.jsx)(n.td,{children:"Should the search include Static Bodies?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Array.<",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),">, Array.<",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),"> - An array of bodies that overlap with the given area."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/components/OverlapRect.js#L1",children:"src/physics/arcade/components/OverlapRect.js#L1"}),(0,i.jsx)(n.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsarcade",children:"Phaser.Physics.Arcade"}),"\n",(0,i.jsx)(n.h2,{id:"getcollideswith",children:"GetCollidesWith"}),"\n",(0,i.jsx)(n.h3,{id:"static-getcollideswithcategories",children:"<static> GetCollidesWith(categories)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Calculates and returns the bitmask needed to determine if the given\ncategories will collide with each other or not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"categories"}),(0,i.jsx)(n.td,{children:"number | Array.<number>"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A unique category bitfield, or an array of them."})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The collision mask."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/GetCollidesWith.js#L7",children:"src/physics/arcade/GetCollidesWith.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getoverlapx",children:"GetOverlapX"}),"\n",(0,i.jsx)(n.h3,{id:"static-getoverlapxbody1-body2-overlaponly-bias",children:"<static> GetOverlapX(body1, body2, overlapOnly, bias)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\naccordingly, including: ",(0,i.jsx)(n.code,{children:"touching.left"}),", ",(0,i.jsx)(n.code,{children:"touching.right"}),", ",(0,i.jsx)(n.code,{children:"touching.none"})," and `overlapX'."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlapOnly"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Is this an overlap only check, or part of separation?"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"bias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding)."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The amount of overlap."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/GetOverlapX.js#L9",children:"src/physics/arcade/GetOverlapX.js#L9"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getoverlapy",children:"GetOverlapY"}),"\n",(0,i.jsx)(n.h3,{id:"static-getoverlapybody1-body2-overlaponly-bias",children:"<static> GetOverlapY(body1, body2, overlapOnly, bias)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(n.p,{children:["Calculates and returns the vertical overlap between two arcade physics bodies and sets their properties\naccordingly, including: ",(0,i.jsx)(n.code,{children:"touching.up"}),", ",(0,i.jsx)(n.code,{children:"touching.down"}),", ",(0,i.jsx)(n.code,{children:"touching.none"})," and `overlapY'."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlapOnly"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Is this an overlap only check, or part of separation?"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"bias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding)."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The amount of overlap."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/GetOverlapY.js#L9",children:"src/physics/arcade/GetOverlapY.js#L9"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"separatex",children:"SeparateX"}),"\n",(0,i.jsx)(n.h3,{id:"static-separatexbody1-body2-overlaponly-bias-overlap",children:"<static> SeparateX(body1, body2, overlapOnly, bias, [overlap])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Separates two overlapping bodies on the X-axis (horizontally)."}),"\n",(0,i.jsx)(n.p,{children:"Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection."}),"\n",(0,i.jsx)(n.p,{children:"The bodies won't be separated if there is no horizontal overlap between them, if they are static, or if either one uses custom logic for its separation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlapOnly"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["If ",(0,i.jsx)(n.code,{children:"true"}),", the bodies will only have their overlap data set and no separation will take place."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"bias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A value to add to the delta value during overlap checking. Used to prevent sprite tunneling."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlap"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"If given then this value will be used as the overlap and no check will be run."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - ",(0,i.jsx)(n.code,{children:"true"})," if the two bodies overlap vertically, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/SeparateX.js#L10",children:"src/physics/arcade/SeparateX.js#L10"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"separatey",children:"SeparateY"}),"\n",(0,i.jsx)(n.h3,{id:"static-separateybody1-body2-overlaponly-bias-overlap",children:"<static> SeparateY(body1, body2, overlapOnly, bias, [overlap])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Separates two overlapping bodies on the Y-axis (vertically)."}),"\n",(0,i.jsx)(n.p,{children:"Separation involves moving two overlapping bodies so they don't overlap anymore and adjusting their velocities based on their mass. This is a core part of collision detection."}),"\n",(0,i.jsx)(n.p,{children:"The bodies won't be separated if there is no vertical overlap between them, if they are static, or if either one uses custom logic for its separation."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlapOnly"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["If ",(0,i.jsx)(n.code,{children:"true"}),", the bodies will only have their overlap data set and no separation will take place."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"bias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A value to add to the delta value during overlap checking. Used to prevent sprite tunneling."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"overlap"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"If given then this value will be used as the overlap and no check will be run."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - ",(0,i.jsx)(n.code,{children:"true"})," if the two bodies overlap vertically, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/SeparateY.js#L10",children:"src/physics/arcade/SeparateY.js#L10"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"setcollisionobject",children:"SetCollisionObject"}),"\n",(0,i.jsx)(n.h3,{id:"static-setcollisionobjectnoneflip-data",children:"<static> SetCollisionObject(noneFlip, [data])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Either sets or creates the Arcade Body Collision object."}),"\n",(0,i.jsx)(n.p,{children:"Mostly only used internally."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"noneFlip"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["Is ",(0,i.jsx)(n.code,{children:"none"})," true or false?"]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"data"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-arcade#ArcadeBodyCollision",children:"Phaser.Types.Physics.Arcade.ArcadeBodyCollision"})}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"The collision data object to populate, or create if not given."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," ",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-arcade#ArcadeBodyCollision",children:"Phaser.Types.Physics.Arcade.ArcadeBodyCollision"})," - The collision data."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/SetCollisionObject.js#L7",children:"src/physics/arcade/SetCollisionObject.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsarcadeprocessx",children:"Phaser.Physics.Arcade.ProcessX"}),"\n",(0,i.jsx)(n.h2,{id:"set",children:"Set"}),"\n",(0,i.jsx)(n.h3,{id:"static-setb1-b2-ov",children:"<static> Set(b1, b2, ov)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Sets all of the local processing values and calculates the velocity exchanges."}),"\n",(0,i.jsxs)(n.p,{children:["Then runs ",(0,i.jsx)(n.code,{children:"BlockCheck"})," and returns the value from it."]}),"\n",(0,i.jsxs)(n.p,{children:["This method is called by ",(0,i.jsx)(n.code,{children:"Phaser.Physics.Arcade.SeparateX"})," and should not be\ncalled directly."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"b1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"b2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ov"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The overlap value."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L25",children:"src/physics/arcade/ProcessX.js#L25"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"blockcheck",children:"BlockCheck"}),"\n",(0,i.jsx)(n.h3,{id:"static-blockcheck",children:"<static> BlockCheck()"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Blocked Direction checks, because it doesn't matter if an object can be pushed\nor not, blocked is blocked."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L71",children:"src/physics/arcade/ProcessX.js#L71"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"check",children:"Check"}),"\n",(0,i.jsx)(n.h3,{id:"static-check",children:"<static> Check()"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The main check function. Runs through one of the four possible tests and returns the results."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - ",(0,i.jsx)(n.code,{children:"true"})," if a check passed, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L118",children:"src/physics/arcade/ProcessX.js#L118"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"run",children:"Run"}),"\n",(0,i.jsx)(n.h3,{id:"static-runside",children:"<static> Run(side)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The main check function. Runs through one of the four possible tests and returns the results."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"side"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The side to test. As passed in by the ",(0,i.jsx)(n.code,{children:"Check"})," function."]})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - Always returns ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L169",children:"src/physics/arcade/ProcessX.js#L169"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runimmovablebody1",children:"RunImmovableBody1"}),"\n",(0,i.jsx)(n.h3,{id:"static-runimmovablebody1blockedstate",children:"<static> RunImmovableBody1(blockedState)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This function is run when Body1 is Immovable and Body2 is not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"blockedState"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The block state value."})]})})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L331",children:"src/physics/arcade/ProcessX.js#L331"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runimmovablebody2",children:"RunImmovableBody2"}),"\n",(0,i.jsx)(n.h3,{id:"static-runimmovablebody2blockedstate",children:"<static> RunImmovableBody2(blockedState)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This function is run when Body2 is Immovable and Body1 is not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"blockedState"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The block state value."})]})})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessX.js#L367",children:"src/physics/arcade/ProcessX.js#L367"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsarcadeprocessy",children:"Phaser.Physics.Arcade.ProcessY"}),"\n",(0,i.jsx)(n.h2,{id:"set-1",children:"Set"}),"\n",(0,i.jsx)(n.h3,{id:"static-setb1-b2-ov-1",children:"<static> Set(b1, b2, ov)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Sets all of the local processing values and calculates the velocity exchanges."}),"\n",(0,i.jsxs)(n.p,{children:["Then runs ",(0,i.jsx)(n.code,{children:"BlockCheck"})," and returns the value from it."]}),"\n",(0,i.jsxs)(n.p,{children:["This method is called by ",(0,i.jsx)(n.code,{children:"Phaser.Physics.Arcade.SeparateY"})," and should not be\ncalled directly."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"b1"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The first Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"b2"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The second Body to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"ov"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The overlap value."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L25",children:"src/physics/arcade/ProcessY.js#L25"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"blockcheck-1",children:"BlockCheck"}),"\n",(0,i.jsx)(n.h3,{id:"static-blockcheck-1",children:"<static> BlockCheck()"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Blocked Direction checks, because it doesn't matter if an object can be pushed\nor not, blocked is blocked."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The BlockCheck result. 0 = not blocked. 1 = Body 1 blocked. 2 = Body 2 blocked."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L71",children:"src/physics/arcade/ProcessY.js#L71"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"check-1",children:"Check"}),"\n",(0,i.jsx)(n.h3,{id:"static-check-1",children:"<static> Check()"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The main check function. Runs through one of the four possible tests and returns the results."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - ",(0,i.jsx)(n.code,{children:"true"})," if a check passed, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L118",children:"src/physics/arcade/ProcessY.js#L118"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"run-1",children:"Run"}),"\n",(0,i.jsx)(n.h3,{id:"static-runside-1",children:"<static> Run(side)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The main check function. Runs through one of the four possible tests and returns the results."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"side"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The side to test. As passed in by the ",(0,i.jsx)(n.code,{children:"Check"})," function."]})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - Always returns ",(0,i.jsx)(n.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L169",children:"src/physics/arcade/ProcessY.js#L169"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runimmovablebody1-1",children:"RunImmovableBody1"}),"\n",(0,i.jsx)(n.h3,{id:"static-runimmovablebody1blockedstate-1",children:"<static> RunImmovableBody1(blockedState)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This function is run when Body1 is Immovable and Body2 is not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"blockedState"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The block state value."})]})})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L331",children:"src/physics/arcade/ProcessY.js#L331"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"runimmovablebody2-1",children:"RunImmovableBody2"}),"\n",(0,i.jsx)(n.h3,{id:"static-runimmovablebody2blockedstate-1",children:"<static> RunImmovableBody2(blockedState)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"This function is run when Body2 is Immovable and Body1 is not."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"blockedState"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The block state value."})]})})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/ProcessY.js#L367",children:"src/physics/arcade/ProcessY.js#L367"}),(0,i.jsx)(n.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsarcadetilemap",children:"Phaser.Physics.Arcade.Tilemap"}),"\n",(0,i.jsx)(n.h2,{id:"processtilecallbacks",children:"ProcessTileCallbacks"}),"\n",(0,i.jsx)(n.h3,{id:"static-processtilecallbackstile-sprite",children:"<static> ProcessTileCallbacks(tile, sprite)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"A function to process the collision callbacks between a single tile and an Arcade Physics enabled Game Object."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tile"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Tile to process."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"sprite"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/gameobjects-sprite",children:"Phaser.GameObjects.Sprite"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Game Object to process with the Tile."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - The result of the callback, ",(0,i.jsx)(n.code,{children:"true"})," for further processing, or ",(0,i.jsx)(n.code,{children:"false"})," to skip this pair."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/ProcessTileCallbacks.js#L7",children:"src/physics/arcade/tilemap/ProcessTileCallbacks.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"processtileseparationx",children:"ProcessTileSeparationX"}),"\n",(0,i.jsx)(n.h3,{id:"static-processtileseparationxbody-x",children:"<static> ProcessTileSeparationX(body, x)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Internal function to process the separation of a physics body from a tile."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Body object to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The x separation amount."})]})]})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/ProcessTileSeparationX.js#L7",children:"src/physics/arcade/tilemap/ProcessTileSeparationX.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"processtileseparationy",children:"ProcessTileSeparationY"}),"\n",(0,i.jsx)(n.h3,{id:"static-processtileseparationybody-y",children:"<static> ProcessTileSeparationY(body, y)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Internal function to process the separation of a physics body from a tile."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Body object to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The y separation amount."})]})]})]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/ProcessTileSeparationY.js#L7",children:"src/physics/arcade/tilemap/ProcessTileSeparationY.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"separatetile",children:"SeparateTile"}),"\n",(0,i.jsx)(n.h3,{id:"static-separatetilei-body-tile-tileworldrect-tilemaplayer-tilebias-islayer",children:"<static> SeparateTile(i, body, tile, tileWorldRect, tilemapLayer, tileBias, isLayer)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"The core separation function to separate a physics body and a tile."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"i"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The index of the tile within the map data."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Body object to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tile"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The tile to collide against."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileWorldRect"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/geom-rectangle",children:"Phaser.Geom.Rectangle"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A rectangle-like object defining the dimensions of the tile."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tilemapLayer"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/tilemaps-tilemaplayer",children:"Phaser.Tilemaps.TilemapLayer"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The tilemapLayer to collide against."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileBias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The tile bias value. Populated by the ",(0,i.jsx)(n.code,{children:"World.TILE_BIAS"})," constant."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isLayer"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Is this check coming from a TilemapLayer or an array of tiles?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - ",(0,i.jsx)(n.code,{children:"true"})," if the body was separated, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/SeparateTile.js#L11",children:"src/physics/arcade/tilemap/SeparateTile.js#L11"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tilecheckx",children:"TileCheckX"}),"\n",(0,i.jsx)(n.h3,{id:"static-tilecheckxbody-tile-tileleft-tileright-tilebias-islayer",children:"<static> TileCheckX(body, tile, tileLeft, tileRight, tileBias, isLayer)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Check the body against the given tile on the X axis.\nUsed internally by the SeparateTile function."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Body object to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tile"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The tile to check."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileLeft"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The left position of the tile within the tile world."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileRight"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The right position of the tile within the tile world."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileBias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The tile bias value. Populated by the ",(0,i.jsx)(n.code,{children:"World.TILE_BIAS"})," constant."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isLayer"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Is this check coming from a TilemapLayer or an array of tiles?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The amount of separation that occurred."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/TileCheckX.js#L9",children:"src/physics/arcade/tilemap/TileCheckX.js#L9"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tilechecky",children:"TileCheckY"}),"\n",(0,i.jsx)(n.h3,{id:"static-tilecheckybody-tile-tiletop-tilebottom-tilebias-islayer",children:"<static> TileCheckY(body, tile, tileTop, tileBottom, tileBias, isLayer)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Check the body against the given tile on the Y axis.\nUsed internally by the SeparateTile function."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The Body object to separate."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tile"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The tile to check."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileTop"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The top position of the tile within the tile world."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileBottom"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The bottom position of the tile within the tile world."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileBias"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsxs)(n.td,{children:["The tile bias value. Populated by the ",(0,i.jsx)(n.code,{children:"World.TILE_BIAS"})," constant."]})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"isLayer"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"Is this check coming from a TilemapLayer or an array of tiles?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," number - The amount of separation that occurred."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/TileCheckY.js#L9",children:"src/physics/arcade/tilemap/TileCheckY.js#L9"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"tileintersectsbody",children:"TileIntersectsBody"}),"\n",(0,i.jsx)(n.h3,{id:"static-tileintersectsbodytileworldrect-body",children:"<static> TileIntersectsBody(tileWorldRect, body)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Checks for intersection between the given tile rectangle-like object and an Arcade Physics body."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"tileWorldRect"}),(0,i.jsx)(n.td,{children:"Object"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"A rectangle object that defines the tile placement in the world."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"body"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The body to check for intersection against."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," boolean - Returns ",(0,i.jsx)(n.code,{children:"true"})," of the tile intersects with the body, otherwise ",(0,i.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/arcade/tilemap/TileIntersectsBody.js#L7",children:"src/physics/arcade/tilemap/TileIntersectsBody.js#L7"}),(0,i.jsx)(n.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsmatter",children:"Phaser.Physics.Matter"}),"\n",(0,i.jsx)(n.h2,{id:"mattergameobject",children:"MatterGameObject"}),"\n",(0,i.jsx)(n.h3,{id:"static-mattergameobjectworld-gameobject-options-addtoworld",children:"<static> MatterGameObject(world, gameObject, [options], [addToWorld])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"A Matter Game Object is a generic object that allows you to combine any Phaser Game Object,\nincluding those you have extended or created yourself, with all of the Matter Components."}),"\n",(0,i.jsxs)(n.p,{children:["This enables you to use component methods such as ",(0,i.jsx)(n.code,{children:"setVelocity"})," or ",(0,i.jsx)(n.code,{children:"isSensor"})," directly from\nthis Game Object."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"default"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"world"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/physics-matter-world",children:"Phaser.Physics.Matter.World"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The Matter world to add the body to."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"gameObject"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"The Game Object that will have the Matter body applied to it."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"options"}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-matter#MatterBodyConfig",children:"Phaser.Types.Physics.Matter.MatterBodyConfig"})," | MatterJS.Body"]}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{}),(0,i.jsx)(n.td,{children:"A Matter Body configuration object, or an instance of a Matter Body."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"addToWorld"}),(0,i.jsx)(n.td,{children:"boolean"}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"true"}),(0,i.jsx)(n.td,{children:"Should the newly created body be immediately added to the World?"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," ",(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})," - The Game Object that was created with the Matter body."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/matter-js/MatterGameObject.js#L26",children:"src/physics/matter-js/MatterGameObject.js#L26"}),(0,i.jsx)(n.br,{}),"\nSince: 3.3.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsmatterphysicseditorparser",children:"Phaser.Physics.Matter.PhysicsEditorParser"}),"\n",(0,i.jsx)(n.h2,{id:"parsebody",children:"parseBody"}),"\n",(0,i.jsx)(n.h3,{id:"static-parsebodyx-y-config-options",children:"<static> parseBody(x, y, config, [options])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Parses a body element exported by PhysicsEditor."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The horizontal world location of the body."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The vertical world location of the body."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"config"}),(0,i.jsx)(n.td,{children:"object"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The body configuration and fixture (child body) definitions, as exported by PhysicsEditor."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"options"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-matter#MatterBodyConfig",children:"Phaser.Types.Physics.Matter.MatterBodyConfig"})}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"An optional Body configuration object that is used to set initial Body properties on creation."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," MatterJS.BodyType - A compound Matter JS Body."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/matter-js/PhysicsEditorParser.js#L24",children:"src/physics/matter-js/PhysicsEditorParser.js#L24"}),(0,i.jsx)(n.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"parsefixture",children:"parseFixture"}),"\n",(0,i.jsx)(n.h3,{id:"static-parsefixturefixtureconfig",children:"<static> parseFixture(fixtureConfig)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:'Parses an element of the "fixtures" list exported by PhysicsEditor'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"fixtureConfig"}),(0,i.jsx)(n.td,{children:"object"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The fixture object to parse."})]})})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Array.<MatterJS.BodyType> - - An array of Matter JS Bodies."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/matter-js/PhysicsEditorParser.js#L70",children:"src/physics/matter-js/PhysicsEditorParser.js#L70"}),(0,i.jsx)(n.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"parsevertices",children:"parseVertices"}),"\n",(0,i.jsx)(n.h3,{id:"static-parseverticesvertexsets-options",children:"<static> parseVertices(vertexSets, [options])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:'Parses the "vertices" lists exported by PhysicsEditor.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"vertexSets"}),(0,i.jsx)(n.td,{children:"array"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The vertex lists to parse."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"options"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-matter#MatterBodyConfig",children:"Phaser.Types.Physics.Matter.MatterBodyConfig"})}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"An optional Body configuration object that is used to set initial Body properties on creation."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," Array.<MatterJS.BodyType> - - An array of Matter JS Bodies."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/matter-js/PhysicsEditorParser.js#L104",children:"src/physics/matter-js/PhysicsEditorParser.js#L104"}),(0,i.jsx)(n.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"phaserphysicsmatterphysicsjsonparser",children:"Phaser.Physics.Matter.PhysicsJSONParser"}),"\n",(0,i.jsx)(n.h2,{id:"parsebody-1",children:"parseBody"}),"\n",(0,i.jsx)(n.h3,{id:"static-parsebodyx-y-config-options-1",children:"<static> parseBody(x, y, config, [options])"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Description:"})}),"\n",(0,i.jsx)(n.p,{children:"Parses a body element from the given JSON data."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"name"}),(0,i.jsx)(n.th,{children:"type"}),(0,i.jsx)(n.th,{children:"optional"}),(0,i.jsx)(n.th,{children:"description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"x"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The horizontal world location of the body."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"y"}),(0,i.jsx)(n.td,{children:"number"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The vertical world location of the body."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"config"}),(0,i.jsx)(n.td,{children:"object"}),(0,i.jsx)(n.td,{children:"No"}),(0,i.jsx)(n.td,{children:"The body configuration data."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"options"}),(0,i.jsx)(n.td,{children:(0,i.jsx)(n.a,{href:"/api-documentation/3.85.2/typedef/types-physics-matter#MatterBodyConfig",children:"Phaser.Types.Physics.Matter.MatterBodyConfig"})}),(0,i.jsx)(n.td,{children:"Yes"}),(0,i.jsx)(n.td,{children:"An optional Body configuration object that is used to set initial Body properties on creation."})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns:"})," MatterJS.BodyType - A Matter JS Body."]}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["Source: ",(0,i.jsx)(n.a,{href:"https://github.com/phaserjs/phaser/blob/v3.85.2/src/physics/matter-js/PhysicsJSONParser.js#L53",children:"src/physics/matter-js/PhysicsJSONParser.js#L53"}),(0,i.jsx)(n.br,{}),"\nSince: 3.22.0"]}),"\n"]})]})}function o(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},28453:function(e,n,s){s.d(n,{R:()=>c,x:()=>d});var t=s(96540);let i={},r=t.createContext(i);function c(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);
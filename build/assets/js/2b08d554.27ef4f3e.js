"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["8082"],{68664:function(e,t,n){n.r(t),n.d(t,{metadata:()=>o,default:()=>l,frontMatter:()=>r,contentTitle:()=>a,toc:()=>h,assets:()=>c});var o=JSON.parse('{"id":"phaser-editor/scene-editor/script-node/script-node-constraints","title":"Adding constraints to Script Nodes","description":"Script Nodes are a powerful tool for creating a hierarchy of reusable behaviors in your game. However, it is sometimes necessary to restrict how these nodes can be connected or used to keep the game logic consistent and avoid errors. This is especially useful when you have developers and designers working together on the team, and you want to make sure that the nodes are connected consistently and follow the rules of the game.","source":"@site/docs/phaser-editor/scene-editor/script-node/script-node-constraints.md","sourceDirName":"phaser-editor/scene-editor/script-node","slug":"/phaser-editor/scene-editor/script-node/script-node-constraints","permalink":"/phaser-editor/scene-editor/script-node/script-node-constraints","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"slug":"script-node-constraints","title":"Adding constraints to Script Nodes"},"sidebar":"PhaserEditorSidebar","previous":{"title":"ScriptNode\'s properties","permalink":"/phaser-editor/scene-editor/script-node/script-node-properties"},"next":{"title":"User Components","permalink":"/phaser-editor/scene-editor/user-components"}}'),s=n(74848),i=n(28453);let r={slug:"script-node-constraints",title:"Adding constraints to Script Nodes"},a,c={},h=[{value:"Adding Constraints to Script Nodes",id:"adding-constraints-to-script-nodes",level:2},{value:"Constraints list",id:"constraints-list",level:3},{value:"Adding a new constraint",id:"adding-a-new-constraint",level:3},{value:"Logic operators",id:"logic-operators",level:3}];function d(e){let t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"Script Nodes are a powerful tool for creating a hierarchy of reusable behaviors in your game. However, it is sometimes necessary to restrict how these nodes can be connected or used to keep the game logic consistent and avoid errors. This is especially useful when you have developers and designers working together on the team, and you want to make sure that the nodes are connected consistently and follow the rules of the game."}),"\n",(0,s.jsx)(t.p,{children:"For this, we have implemented a constraint system that allows you to define which Script Nodes can connect to each other."}),"\n",(0,s.jsx)(t.p,{children:"There are two types of constraints that you can apply to your Script Nodes:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"General constraints: These constraints can evaluate the context of the Script Node and decide whether the connection is valid or not. For example, you could have a constraint that checks if a Script Node is added to a scene and not to an object. Or validate if the node has a no-children constraint, which means it cannot have any child Script Nodes connected to it."}),"\n",(0,s.jsx)(t.li,{children:'Type constraints: these constraints define what type of Script Nodes can connect to each other. For example, you can allow a Script Node of type "Event" to only connect to Script Nodes of type "Action".'}),"\n",(0,s.jsxs)(t.li,{children:["Tag constraints: These constraints allow a Script Node to connect only to other Script Nodes that ",(0,s.jsx)(t.a,{href:"../prefabs/prefab-tags",children:"have a specific tag"}),"."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.em,{children:["(Learn more about ",(0,s.jsx)(t.a,{href:"../prefabs/prefab-tags",children:"prefab tags"}),")"]})}),"\n",(0,s.jsx)(t.p,{children:"These restrictions will be taken into account when connecting Script Nodes in the Scene Editor. If a Script Node does not comply with the defined restrictions, it will not be able to connect to another object. Therefore, the dialog where the Script Nodes available for connection are shown, will only display those that comply with the restrictions of the object to which you are trying to connect."}),"\n",(0,s.jsxs)(t.p,{children:["The following image shows the ",(0,s.jsx)(t.strong,{children:"Add Script"}),' dialog when the user tries to add a new node script to a "list of pets" script. As you can see, it only shows the "pets" scripts, filtering out the ones that do not meet the constraints defined in the prefab of the "list of pets" script node.']}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Add Script dialog filtering",src:n(78436).A+"",width:"946",height:"812"})}),"\n",(0,s.jsx)(t.h2,{id:"adding-constraints-to-script-nodes",children:"Adding Constraints to Script Nodes"}),"\n",(0,s.jsx)(t.p,{children:"As we have explained in previous chapters, to create your own Script Node you must create a Script Node prefab. Therefore, it is there that you must define the constraints that you want to apply to your Script Node."}),"\n",(0,s.jsxs)(t.p,{children:["In particular, we have introduced a new section of the Inspector view called ",(0,s.jsx)(t.strong,{children:"Prefab Constraints"}),". It contains a list of the constraints you have already added to the prefab, a button to add a new constraint (",(0,s.jsx)(t.strong,{children:"Add Constraint"}),"), and the parameters where you set the logical operators that will be used to combine the constraints."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Prefab node constraints section",src:n(33478).A+"",width:"744",height:"528"})}),"\n",(0,s.jsx)(t.h3,{id:"constraints-list",children:"Constraints list"}),"\n",(0,s.jsx)(t.p,{children:"The constraints list shows the constraints you have already added to the prefab. It is important to note that constraints are inherited. That is, a prefab variant inherits the constraints from the original prefab. Therefore, if you add a constraint to a prefab variant, it will be combined with all the prefabs that inherit from it."}),"\n",(0,s.jsxs)(t.p,{children:["Let's look at an example of a ",(0,s.jsx)(t.strong,{children:"DogScript"})," prefab that inherits from a ",(0,s.jsx)(t.strong,{children:"PetScript"})," prefab. The prefab ",(0,s.jsx)(t.strong,{children:"PetScript"})," has the constraint ",(0,s.jsx)(t.code,{children:'Parent has tag "list of pets"'}),", and the prefab ",(0,s.jsx)(t.strong,{children:"DogScript"})," has the constraint ",(0,s.jsx)(t.code,{children:"Child is instance of 'DogPartScript'"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The following image shows the Inspector view of the ",(0,s.jsx)(t.strong,{children:"DogScript"})," prefab. As you can see, both constraints are listed in the ",(0,s.jsx)(t.strong,{children:"Prefab Constraints"})," section:"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Prefab constraints inheritance",src:n(76591).A+"",width:"744",height:"684"})}),"\n",(0,s.jsx)(t.p,{children:"Look you can only delete the local constraints, not the inherited ones. If you want to delete an inherited constraint, you must do it in the parent prefab."}),"\n",(0,s.jsx)(t.h3,{id:"adding-a-new-constraint",children:"Adding a new constraint"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"Add Constraint"})," button allows you to add a new constraint to the prefab. Clicking this button will display a menu with the available constraint options. You can choose between:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Parent has tag"})," - Allows the Script Node to connect only if its parent has a specific tag. When you select this option, a dialog will appear where you can select the tag you want to use as a constraint."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Child has tag"})," - Allows a child node to only connect to this node if the child node has a specific tag."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Parent is instance of"})," - Allows the Script Node to connect only if its parent is an instance of a specific prefab or Phaser game object type. When you select this option, a dialog will appear where you can select the prefab or Phaser type you want to use as a constraint."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Child is instance of"})," - Allows a child node to only connect to this node if the child node is an instance of a specific prefab or Phaser game object type."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Parent is the scene"})," - Allows the Script Node to connect only if its parent is the scene. This constraint is useful for Script Nodes that must be added to the scene and not to a specific object."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"No children allowed"})," - Allows the Script Node to have no child nodes connected to it. This constraint is useful for Script Nodes that should not have a hierarchy of child nodes."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"logic-operators",children:"Logic operators"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"Condition"})," parameter allows you to set the logical operator that will be used to combine the local constraints. You can choose between ",(0,s.jsx)(t.strong,{children:"Match All"})," or ",(0,s.jsx)(t.strong,{children:"Match Any"}),". Match All means that all constraints must be true for the connection to be valid. Match Any means that at least one of the constraints must be true for the connection to be valid."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.strong,{children:"Inheritance Condition"})," parameter allows you to set the logical operator that will be used to combine the inherited constraints. You can choose between ",(0,s.jsx)(t.strong,{children:"Match All"}),", ",(0,s.jsx)(t.strong,{children:"Match Any"})," or ",(0,s.jsx)(t.strong,{children:"Override"}),". To determine if a connection is valid, the system will first check the inherited constraints and then the local constraints, then combine both results using the selected operator in the ",(0,s.jsx)(t.strong,{children:"Inheritance Condition"}),". If the operator is set to:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Match All"}),": The inherited constraints result should be true, and the local constraints result must be true for the connection to be valid."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Match All"}),": The inherited constraints result should be true, or the local constraints result must be true for the connection to be valid."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Override"}),": The inherited constraints result is ignored, and only the local constraints result is used to determine if the connection is valid."]}),"\n"]})]})}function l(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},78436:function(e,t,n){n.d(t,{A:()=>o});let o=n.p+"assets/images/script-node-constraints-filtering-20250604-05ba40d4c5d314621bc74092c9122f82.webp"},76591:function(e,t,n){n.d(t,{A:()=>o});let o=n.p+"assets/images/script-node-constraints-inheritance-20250801-f0bed2c8a8fb3772ff7a4eb7a3d2553c.webp"},33478:function(e,t,n){n.d(t,{A:()=>o});let o=n.p+"assets/images/script-node-constraints-section-20250801-a402a22ecf875a171840c8e2f83a0a29.webp"},28453:function(e,t,n){n.d(t,{R:()=>r,x:()=>a});var o=n(96540);let s={},i=o.createContext(s);function r(e){let t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["31179"],{71954:function(e,n,t){t.r(n),t.d(n,{metadata:()=>s,default:()=>p,frontMatter:()=>i,contentTitle:()=>a,toc:()=>l,assets:()=>c});var s=JSON.parse('{"id":"phaser-editor/scene-editor/user-components/user-components-super-class","title":"A base class for your components","description":"In the previous section, we explored how you can implement behaviors by listening to Phaser events. There, we implemented an EventComponent base class for all the components.","source":"@site/docs/phaser-editor/scene-editor/user-components/user-components-super-class.md","sourceDirName":"phaser-editor/scene-editor/user-components","slug":"/phaser-editor/scene-editor/user-components/user-components-super-class","permalink":"/phaser-editor/scene-editor/user-components/user-components-super-class","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"slug":"user-components-super-class","title":"A base class for your components"},"sidebar":"PhaserEditorSidebar","previous":{"title":"Implementing behaviors with the Phaser events","permalink":"/phaser-editor/scene-editor/user-components/user-components-start-update-methods"},"next":{"title":"The awake event","permalink":"/phaser-editor/scene-editor/user-components/user-components-awake-event"}}'),o=t(74848),r=t(28453);let i={slug:"user-components-super-class",title:"A base class for your components"},a,c={},l=[{value:"Inside the UserComponent class",id:"inside-the-usercomponent-class",level:2}];function h(e){let n={a:"a",code:"code",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["In the previous section, we explored how you can implement behaviors by listening to Phaser events. There, we implemented an ",(0,o.jsx)(n.code,{children:"EventComponent"})," base class for all the components."]}),"\n",(0,o.jsx)(n.p,{children:"The components concept provided by Phaser Editor is flexible. However, we think it is a good idea to propose a way of implementing the components."}),"\n",(0,o.jsxs)(n.p,{children:["For this reason, we created a ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class that you can use as the base class for all your components. This class is included in the ",(0,o.jsx)(n.a,{href:"https://github.com/phaserjs/editor-scripts-core",children:"phasereditor2d-scripts-core"})," library and should be included in your project if you created it with a Phaser Editor project template."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"../script-node/script-node-libraries",children:"Learn more about script libraries"})}),"\n",(0,o.jsxs)(n.p,{children:["If you are not using script libraries, you have the option of telling the editor to generate the ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class and it will create a file and \u201Cwrite the code for you\u201D."]}),"\n",(0,o.jsxs)(n.p,{children:["The procedure is simple, just open the context menu of the User Components Editor. In the ",(0,o.jsx)(n.strong,{children:"Resources"})," menu, there are options for creating the ",(0,o.jsx)(n.code,{children:"UserComponent.js"})," files in different formats:"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-user-components-create-base-class-file-04012021.webp",alt:"Context menu for creating the UserComponent.js file."})}),"\n",(0,o.jsx)(n.p,{children:"The options are:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create UserComponent.js"}),": creates a ",(0,o.jsx)(n.code,{children:"UserComponent.js"})," file with JavaScript code."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create UserComponent.ts"}),": creates a ",(0,o.jsx)(n.code,{children:"UserComponent.ts"})," file with TypeScript code."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create UserComponent.js (ES Modules)"}),": creates a ",(0,o.jsx)(n.code,{children:"UserComponent.js"})," file with a JavaScript file, using the ES module exporting rules."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Create UserComponent.ts (ES Module)"}),": creates a ",(0,o.jsx)(n.code,{children:"UserComponent.ts"})," file with TypeScript code, using the ES module exporting rules."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"If the file exists, the editor asks if you confirm replacing it."}),"\n",(0,o.jsx)(n.p,{children:"You can do this operation just once unless you mess up the file content and want to reset it."}),"\n",(0,o.jsxs)(n.p,{children:["Once the file is created, you can use the ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class as the super-class of your components."]}),"\n",(0,o.jsx)(n.h2,{id:"inside-the-usercomponent-class",children:"Inside the UserComponent class"}),"\n",(0,o.jsxs)(n.p,{children:["In the ",(0,o.jsx)(n.a,{href:"./user-components-start-update-methods",children:"Implementing behaviors with the Phaser events"})," section, we explain how a component can register listeners to the Phaser events, for implementing a particular behavior. The ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class does the same. It listens for Phaser events and calls special methods that could be overridden in derived classes. These are the methods present by the ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"class UserComponent {\n\n    constructor(gameObject) {\n        // registers the event listeners and call the methods\n    }\n\n    awake() { }\n\n    start() { }\n\n    update() { }\n\n    destroy() { }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"It registers the event listeners in the constructor:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'constructor(gameObject) {\n\n    this.scene = gameObject.scene;\n\n    const listenAwake =\n            this.awake !== UserComponent.prototype.awake;\n    const listenStart =\n            this.start !== UserComponent.prototype.start;\n    const listenUpdate =\n            this.update !== UserComponent.prototype.update;\n    const listenDestroy =\n            this.destroy !== UserComponent.prototype.destroy;\n\n    if (listenAwake) {\n\n        this.scene.events.once("scene-awake", this.awake, this);\n    }\n\n    if (listenStart) {\n\n        this.scene.events.once(\n            Phaser.Scenes.Events.UPDATE, this.start, this);\n    }\n\n    if (listenUpdate) {\n\n        this.scene.events.on(\n            Phaser.Scenes.Events.UPDATE, this.update, this);\n    }\n\n    if (listenStart || listenUpdate || listenDestroy) {\n\n        gameObject.on(Phaser.GameObjects.Events.DESTROY, () => {\n\n            this.scene.events.off(\n                Phaser.Scenes.Events.UPDATE, this.start, this);\n            this.scene.events.off(\n                Phaser.Scenes.Events.UPDATE, this.update, this);\n\n            if (listenDestroy) {\n\n                this.destroy();\n            }\n        });\n    }\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["But let\u2019s go step by step. First, it checks what events to listen to. Notice that the methods ",(0,o.jsx)(n.strong,{children:"awake()"}),", ",(0,o.jsx)(n.strong,{children:"start()"}),", etc\u2026, are empty. So, if the component instance doesn\u2019t provide a different implementation for one of these methods, then it means it can skip calling that method. Then the first thing is to know what methods to call:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const listenAwake =\n    this.awake !== UserComponent.prototype.awake;\n\nconst listenStart =\n    this.start !== UserComponent.prototype.start;\n\nconst listenUpdate =\n    this.update !== UserComponent.prototype.update;\n\nconst listenDestroy =\n    this.destroy !== UserComponent.prototype.destroy;\n"})}),"\n",(0,o.jsx)(n.p,{children:"In the following lines, it adds the listeners to the Phaser events, but only if it is needed:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"...\nif (listenStart) {\n\n    this.scene.events.once(Phaser.Scenes.Events.UPDATE, this.start, this);\n}\n\nif (listenUpdate) {\n\n    this.scene.events.on(Phaser.Scenes.Events.UPDATE, this.update, this);\n}\n...\n"})}),"\n",(0,o.jsx)(n.p,{children:"At the end of the constructor, it registers a listener to the game object\u2019s destroy event and removes all the listeners. It does it to avoid calling a method if the object is not active."}),"\n",(0,o.jsxs)(n.p,{children:["When you create a new component, you can update it by just implementing the ",(0,o.jsx)(n.strong,{children:"update()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"class RotateObject extends UserComponent {\n\n    constructor(gameObject) {\n        super(gameObject);\n    }\n\n    ...\n\n    update() {\n\n        // this method is called when the scene\n        // emits the UPDATE event\n\n        this.gameObject.angle += 1;\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"UserComponent"})," class is \u201Cgood enough\u201D for many cases, but you can modify it or use a completely different one. Or use the Phaser events directly in your components."]})]})}function p(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},28453:function(e,n,t){t.d(n,{R:()=>i,x:()=>a});var s=t(96540);let o={},r=s.createContext(o);function i(e){let n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["10271"],{54380:function(e,s,n){n.r(s),n.d(s,{metadata:()=>c,default:()=>o,frontMatter:()=>r,contentTitle:()=>d,toc:()=>l,assets:()=>a});var c=JSON.parse('{"id":"class/Phaser.Physics.Arcade.ArcadePhysics","title":"ArcadePhysics","description":"Phaser.Physics.Arcade.ArcadePhysics","source":"@site/api-documentation_versioned_docs/version-3.87.0/class/Phaser.Physics.Arcade.ArcadePhysics.md","sourceDirName":"class","slug":"/class/physics-arcade-arcadephysics","permalink":"/api-documentation/class/physics-arcade-arcadephysics","draft":false,"unlisted":false,"tags":[],"version":"3.87.0","frontMatter":{"visibility":"public","slug":"physics-arcade-arcadephysics","title":"ArcadePhysics","description":"Phaser.Physics.Arcade.ArcadePhysics","seoTitle":"Phaser.Physics.Arcade.ArcadePhysics","seoDescription":"Phaser v3.87.0 Documentation for Phaser.Physics.Arcade.ArcadePhysics","ogImage":null},"sidebar":"PhaserApiSidebar","previous":{"title":"Vector4","permalink":"/api-documentation/class/math-vector4"},"next":{"title":"Body","permalink":"/api-documentation/class/physics-arcade-body"}}'),i=n(74848),t=n(28453);let r={visibility:"public",slug:"physics-arcade-arcadephysics",title:"ArcadePhysics",description:"Phaser.Physics.Arcade.ArcadePhysics",seoTitle:"Phaser.Physics.Arcade.ArcadePhysics",seoDescription:"Phaser v3.87.0 Documentation for Phaser.Physics.Arcade.ArcadePhysics",ogImage:null},d,a={},l=[{value:"add",id:"add",level:2},{value:"add: Phaser.Physics.Arcade.Factory",id:"add-phaserphysicsarcadefactory",level:3},{value:"config",id:"config",level:2},{value:"config: Phaser.Types.Physics.Arcade.ArcadeWorldConfig",id:"config-phasertypesphysicsarcadearcadeworldconfig",level:3},{value:"scene",id:"scene",level:2},{value:"scene: Phaser.Scene",id:"scene-phaserscene",level:3},{value:"systems",id:"systems",level:2},{value:"systems: Phaser.Scenes.Systems",id:"systems-phaserscenessystems",level:3},{value:"world",id:"world",level:2},{value:"world: Phaser.Physics.Arcade.World",id:"world-phaserphysicsarcadeworld",level:3},{value:"accelerateTo",id:"accelerateto",level:2},{value:"&lt;instance&gt; accelerateTo(gameObject, x, y, [speed], [xSpeedMax], [ySpeedMax])",id:"instance-acceleratetogameobject-x-y-speed-xspeedmax-yspeedmax",level:3},{value:"accelerateToObject",id:"acceleratetoobject",level:2},{value:"&lt;instance&gt; accelerateToObject(gameObject, destination, [speed], [xSpeedMax], [ySpeedMax])",id:"instance-acceleratetoobjectgameobject-destination-speed-xspeedmax-yspeedmax",level:3},{value:"closest",id:"closest",level:2},{value:"&lt;instance&gt; closest(source, [targets])",id:"instance-closestsource-targets",level:3},{value:"collide",id:"collide",level:2},{value:"&lt;instance&gt; collide(object1, [object2], [collideCallback], [processCallback], [callbackContext])",id:"instance-collideobject1-object2-collidecallback-processcallback-callbackcontext",level:3},{value:"collideTiles",id:"collidetiles",level:2},{value:"&lt;instance&gt; collideTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])",id:"instance-collidetilessprite-tiles-collidecallback-processcallback-callbackcontext",level:3},{value:"destroy",id:"destroy",level:2},{value:"&lt;instance&gt; destroy()",id:"instance-destroy",level:3},{value:"disableUpdate",id:"disableupdate",level:2},{value:"&lt;instance&gt; disableUpdate()",id:"instance-disableupdate",level:3},{value:"enableUpdate",id:"enableupdate",level:2},{value:"&lt;instance&gt; enableUpdate()",id:"instance-enableupdate",level:3},{value:"furthest",id:"furthest",level:2},{value:"&lt;instance&gt; furthest(source, [targets])",id:"instance-furthestsource-targets",level:3},{value:"getConfig",id:"getconfig",level:2},{value:"&lt;instance&gt; getConfig()",id:"instance-getconfig",level:3},{value:"moveTo",id:"moveto",level:2},{value:"&lt;instance&gt; moveTo(gameObject, x, y, [speed], [maxTime])",id:"instance-movetogameobject-x-y-speed-maxtime",level:3},{value:"moveToObject",id:"movetoobject",level:2},{value:"&lt;instance&gt; moveToObject(gameObject, destination, [speed], [maxTime])",id:"instance-movetoobjectgameobject-destination-speed-maxtime",level:3},{value:"nextCategory",id:"nextcategory",level:2},{value:"&lt;instance&gt; nextCategory()",id:"instance-nextcategory",level:3},{value:"overlap",id:"overlap",level:2},{value:"&lt;instance&gt; overlap(object1, [object2], [overlapCallback], [processCallback], [callbackContext])",id:"instance-overlapobject1-object2-overlapcallback-processcallback-callbackcontext",level:3},{value:"overlapCirc",id:"overlapcirc",level:2},{value:"&lt;instance&gt; overlapCirc(x, y, radius, [includeDynamic], [includeStatic])",id:"instance-overlapcircx-y-radius-includedynamic-includestatic",level:3},{value:"overlapRect",id:"overlaprect",level:2},{value:"&lt;instance&gt; overlapRect(x, y, width, height, [includeDynamic], [includeStatic])",id:"instance-overlaprectx-y-width-height-includedynamic-includestatic",level:3},{value:"overlapTiles",id:"overlaptiles",level:2},{value:"&lt;instance&gt; overlapTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])",id:"instance-overlaptilessprite-tiles-collidecallback-processcallback-callbackcontext",level:3},{value:"pause",id:"pause",level:2},{value:"&lt;instance&gt; pause()",id:"instance-pause",level:3},{value:"resume",id:"resume",level:2},{value:"&lt;instance&gt; resume()",id:"instance-resume",level:3},{value:"shutdown",id:"shutdown",level:2},{value:"&lt;instance&gt; shutdown()",id:"instance-shutdown",level:3},{value:"velocityFromAngle",id:"velocityfromangle",level:2},{value:"&lt;instance&gt; velocityFromAngle(angle, [speed], [vec2])",id:"instance-velocityfromangleangle-speed-vec2",level:3},{value:"velocityFromRotation",id:"velocityfromrotation",level:2},{value:"&lt;instance&gt; velocityFromRotation(rotation, [speed], [vec2])",id:"instance-velocityfromrotationrotation-speed-vec2",level:3},{value:"boot",id:"boot",level:2},{value:"&lt;instance&gt; boot()",id:"instance-boot",level:3},{value:"start",id:"start",level:2},{value:"&lt;instance&gt; start()",id:"instance-start",level:3}];function h(e){let s={a:"a",blockquote:"blockquote",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation."}),"\n",(0,i.jsx)(s.p,{children:"It also holds some useful methods for moving and rotating Arcade Physics Bodies."}),"\n",(0,i.jsxs)(s.p,{children:["You can access it from within a Scene using ",(0,i.jsx)(s.code,{children:"this.physics"}),"."]}),"\n",(0,i.jsx)(s.p,{children:"Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable"}),"\n",(0,i.jsx)(s.p,{children:"for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other."}),"\n",(0,i.jsx)(s.p,{children:"The separation that stops two objects penetrating may create a new penetration against a different object. If you"}),"\n",(0,i.jsx)(s.p,{children:"require a high level of stability please consider using an alternative physics system, such as Matter.js."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Constructor"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.code,{children:"new ArcadePhysics(scene)"})}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsx)(s.tbody,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"scene"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/scene",children:"Phaser.Scene"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"The Scene that this Plugin belongs to."})]})})]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Scope"}),": static"]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L21",children:"src/physics/arcade/ArcadePhysics.js#L21"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.h1,{id:"public-members",children:"Public Members"}),"\n",(0,i.jsx)(s.h2,{id:"add",children:"add"}),"\n",(0,i.jsxs)(s.h3,{id:"add-phaserphysicsarcadefactory",children:["add: ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-factory",children:"Phaser.Physics.Arcade.Factory"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"An object holding the Arcade Physics factory methods."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L82",children:"src/physics/arcade/ArcadePhysics.js#L82"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"config",children:"config"}),"\n",(0,i.jsxs)(s.h3,{id:"config-phasertypesphysicsarcadearcadeworldconfig",children:["config: ",(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeWorldConfig",children:"Phaser.Types.Physics.Arcade.ArcadeWorldConfig"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["A configuration object. Union of the ",(0,i.jsx)(s.code,{children:"physics.arcade.*"})," properties of the GameConfig and SceneConfig objects."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L64",children:"src/physics/arcade/ArcadePhysics.js#L64"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"scene",children:"scene"}),"\n",(0,i.jsxs)(s.h3,{id:"scene-phaserscene",children:["scene: ",(0,i.jsx)(s.a,{href:"/api-documentation/class/scene",children:"Phaser.Scene"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"The Scene that this Plugin belongs to."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L46",children:"src/physics/arcade/ArcadePhysics.js#L46"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"systems",children:"systems"}),"\n",(0,i.jsxs)(s.h3,{id:"systems-phaserscenessystems",children:["systems: ",(0,i.jsx)(s.a,{href:"/api-documentation/class/scenes-systems",children:"Phaser.Scenes.Systems"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"The Scene's Systems."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L55",children:"src/physics/arcade/ArcadePhysics.js#L55"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"world",children:"world"}),"\n",(0,i.jsxs)(s.h3,{id:"world-phaserphysicsarcadeworld",children:["world: ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"The physics simulation."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L73",children:"src/physics/arcade/ArcadePhysics.js#L73"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h1,{id:"public-methods",children:"Public Methods"}),"\n",(0,i.jsx)(s.h2,{id:"accelerateto",children:"accelerateTo"}),"\n",(0,i.jsx)(s.h3,{id:"instance-acceleratetogameobject-x-y-speed-xspeedmax-yspeedmax",children:"<instance> accelerateTo(gameObject, x, y, [speed], [xSpeedMax], [ySpeedMax])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)"}),"\n",(0,i.jsx)(s.p,{children:"You must give a maximum speed value, beyond which the game object won't go any faster."}),"\n",(0,i.jsx)(s.p,{children:"Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course."}),"\n",(0,i.jsx)(s.p,{children:"Note: The game object doesn't stop moving once it reaches the destination coordinates."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"gameObject"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Any Game Object with an Arcade Physics body."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"x"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The x coordinate to accelerate towards."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"y"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The y coordinate to accelerate towards."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The acceleration (change in speed) in pixels per second squared."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"xSpeedMax"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"500"}),(0,i.jsx)(s.td,{children:"The maximum x velocity the game object can reach."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"ySpeedMax"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"500"}),(0,i.jsx)(s.td,{children:"The maximum y velocity the game object can reach."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," number - The angle (in radians) that the object should be visually set to in order to match its new velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L378",children:"src/physics/arcade/ArcadePhysics.js#L378"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"acceleratetoobject",children:"accelerateToObject"}),"\n",(0,i.jsx)(s.h3,{id:"instance-acceleratetoobjectgameobject-destination-speed-xspeedmax-yspeedmax",children:"<instance> accelerateToObject(gameObject, destination, [speed], [xSpeedMax], [ySpeedMax])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)"}),"\n",(0,i.jsx)(s.p,{children:"You must give a maximum speed value, beyond which the game object won't go any faster."}),"\n",(0,i.jsx)(s.p,{children:"Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course."}),"\n",(0,i.jsx)(s.p,{children:"Note: The game object doesn't stop moving once it reaches the destination coordinates."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"gameObject"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Any Game Object with an Arcade Physics body."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"destination"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The Game Object to move towards. Can be any object but must have visible x/y properties."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The acceleration (change in speed) in pixels per second squared."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"xSpeedMax"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"500"}),(0,i.jsx)(s.td,{children:"The maximum x velocity the game object can reach."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"ySpeedMax"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"500"}),(0,i.jsx)(s.td,{children:"The maximum y velocity the game object can reach."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," number - The angle (in radians) that the object should be visually set to in order to match its new velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L414",children:"src/physics/arcade/ArcadePhysics.js#L414"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"closest",children:"closest"}),"\n",(0,i.jsx)(s.h3,{id:"instance-closestsource-targets",children:"<instance> closest(source, [targets])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Finds the Body or Game Object closest to a source point or object."}),"\n",(0,i.jsxs)(s.p,{children:["If a ",(0,i.jsx)(s.code,{children:"targets"})," argument is passed, this method finds the closest of those."]}),"\n",(0,i.jsx)(s.p,{children:"The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies."}),"\n",(0,i.jsxs)(s.p,{children:["If no ",(0,i.jsx)(s.code,{children:"targets"})," argument is passed, this method finds the closest Dynamic Body."]}),"\n",(0,i.jsx)(s.p,{children:"If two or more targets are the exact same distance from the source point, only the first target"}),"\n",(0,i.jsx)(s.p,{children:"is returned."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Tags:"})}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"generic"}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"source"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-math#Vector2Like",children:"Phaser.Types.Math.Vector2Like"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsxs)(s.td,{children:["Any object with public ",(0,i.jsx)(s.code,{children:"x"})," and ",(0,i.jsx)(s.code,{children:"y"})," properties, such as a Game Object or Geometry object."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"targets"}),(0,i.jsx)(s.td,{children:"Array.<Target>"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"The targets."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," Target, null - The target closest to the given source point."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L438",children:"src/physics/arcade/ArcadePhysics.js#L438"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"collide",children:"collide"}),"\n",(0,i.jsx)(s.h3,{id:"instance-collideobject1-object2-collidecallback-processcallback-callbackcontext",children:"<instance> collide(object1, [object2], [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Performs a collision check and separation between the two physics enabled objects given, which can be single"}),"\n",(0,i.jsx)(s.p,{children:"Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups."}),"\n",(0,i.jsxs)(s.p,{children:["If you don't require separation then use ",(0,i.jsx)(s.a,{href:"#overlap",children:"#overlap"})," instead."]}),"\n",(0,i.jsx)(s.p,{children:"If two Groups or arrays are passed, each member of one will be tested against each member of the other."}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.strong,{children:"only"})," one Group is passed (as ",(0,i.jsx)(s.code,{children:"object1"}),"), each member of the Group will be collided against the other members."]}),"\n",(0,i.jsxs)(s.p,{children:["If ",(0,i.jsx)(s.strong,{children:"only"})," one Array is passed, the array is iterated and every element in it is tested against the others."]}),"\n",(0,i.jsxs)(s.p,{children:["Two callbacks can be provided. The ",(0,i.jsx)(s.code,{children:"collideCallback"})," is invoked if a collision occurs and the two colliding"]}),"\n",(0,i.jsx)(s.p,{children:"objects are passed to it."}),"\n",(0,i.jsx)(s.p,{children:"Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable"}),"\n",(0,i.jsx)(s.p,{children:"for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other."}),"\n",(0,i.jsx)(s.p,{children:"The separation that stops two objects penetrating may create a new penetration against a different object. If you"}),"\n",(0,i.jsx)(s.p,{children:"require a high level of stability please consider using an alternative physics system, such as Matter.js."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"object1"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"The first object or array of objects to check."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"object2"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["The second object or array of objects to check, or ",(0,i.jsx)(s.code,{children:"undefined"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"collideCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"processCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,i.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,i.jsx)(s.code,{children:"true"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"callbackContext"}),(0,i.jsx)(s.td,{children:"*"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," boolean - True if any overlapping Game Objects were separated, otherwise false."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L249",children:"src/physics/arcade/ArcadePhysics.js#L249"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"collidetiles",children:"collideTiles"}),"\n",(0,i.jsx)(s.h3,{id:"instance-collidetilessprite-tiles-collidecallback-processcallback-callbackcontext",children:"<instance> collideTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects."}),"\n",(0,i.jsxs)(s.p,{children:["You should generally use the ",(0,i.jsx)(s.code,{children:"collide"})," method instead, with a Sprite vs. a Tilemap Layer, as that will perform"]}),"\n",(0,i.jsx)(s.p,{children:"tile filtering and culling for you, as well as handle the interesting face collision automatically."}),"\n",(0,i.jsx)(s.p,{children:"This method is offered for those who would like to check for collision with specific Tiles in a layer, without"}),"\n",(0,i.jsx)(s.p,{children:"having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions"}),"\n",(0,i.jsx)(s.p,{children:"on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,"}),"\n",(0,i.jsx)(s.p,{children:"you should filter them before passing them to this method."}),"\n",(0,i.jsxs)(s.p,{children:["Important: Use of this method skips the ",(0,i.jsx)(s.code,{children:"interesting faces"})," system that Tilemap Layers use. This means if you have"]}),"\n",(0,i.jsx)(s.p,{children:"say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the"}),"\n",(0,i.jsx)(s.p,{children:"tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on"}),"\n",(0,i.jsx)(s.p,{children:"dynamic maps, this method can prove very useful."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"sprite"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"tiles"}),(0,i.jsxs)(s.td,{children:["Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"}),">"]}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"An array of Tiles to check for collision against."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"collideCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"processCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,i.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,i.jsx)(s.code,{children:"true"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"callbackContext"}),(0,i.jsx)(s.td,{children:"any"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,i.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Fires:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_COLLIDE",children:"Phaser.Physics.Arcade.Events#event:TILE_COLLIDE"})]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L291",children:"src/physics/arcade/ArcadePhysics.js#L291"}),(0,i.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"destroy",children:"destroy"}),"\n",(0,i.jsx)(s.h3,{id:"instance-destroy",children:"<instance> destroy()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"The Scene that owns this plugin is being destroyed."}),"\n",(0,i.jsx)(s.p,{children:"We need to shutdown and then kill off all external references."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L732",children:"src/physics/arcade/ArcadePhysics.js#L732"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"disableupdate",children:"disableUpdate"}),"\n",(0,i.jsx)(s.h3,{id:"instance-disableupdate",children:"<instance> disableUpdate()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Causes ",(0,i.jsx)(s.code,{children:"World.update"})," to ",(0,i.jsx)(s.strong,{children:"not"})," be automatically called each time the Scene"]}),"\n",(0,i.jsxs)(s.p,{children:["emits and ",(0,i.jsx)(s.code,{children:"UPDATE"})," event."]}),"\n",(0,i.jsx)(s.p,{children:"If you wish to run the World update at your own rate, or from your own"}),"\n",(0,i.jsx)(s.p,{children:"component, then you should call this method to disable the built-in link,"}),"\n",(0,i.jsxs)(s.p,{children:["and then call ",(0,i.jsx)(s.code,{children:"World.update(delta, time)"})," accordingly."]}),"\n",(0,i.jsxs)(s.p,{children:["Note that ",(0,i.jsx)(s.code,{children:"World.postUpdate"})," is always automatically called when the Scene"]}),"\n",(0,i.jsxs)(s.p,{children:["emits a ",(0,i.jsx)(s.code,{children:"POST_UPDATE"})," event, regardless of this setting."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L162",children:"src/physics/arcade/ArcadePhysics.js#L162"}),(0,i.jsx)(s.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"enableupdate",children:"enableUpdate"}),"\n",(0,i.jsx)(s.h3,{id:"instance-enableupdate",children:"<instance> enableUpdate()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Causes ",(0,i.jsx)(s.code,{children:"World.update"})," to be automatically called each time the Scene"]}),"\n",(0,i.jsxs)(s.p,{children:["emits and ",(0,i.jsx)(s.code,{children:"UPDATE"})," event. This is the default setting, so only needs"]}),"\n",(0,i.jsx)(s.p,{children:"calling if you have specifically disabled it."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L149",children:"src/physics/arcade/ArcadePhysics.js#L149"}),(0,i.jsx)(s.br,{}),"\nSince: 3.50.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"furthest",children:"furthest"}),"\n",(0,i.jsx)(s.h3,{id:"instance-furthestsource-targets",children:"<instance> furthest(source, [targets])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Finds the Body or Game Object farthest from a source point or object."}),"\n",(0,i.jsxs)(s.p,{children:["If a ",(0,i.jsx)(s.code,{children:"targets"})," argument is passed, this method finds the farthest of those."]}),"\n",(0,i.jsx)(s.p,{children:"The targets can be Arcade Physics Game Objects, Dynamic Bodies, or Static Bodies."}),"\n",(0,i.jsxs)(s.p,{children:["If no ",(0,i.jsx)(s.code,{children:"targets"})," argument is passed, this method finds the farthest Dynamic Body."]}),"\n",(0,i.jsx)(s.p,{children:"If two or more targets are the exact same distance from the source point, only the first target"}),"\n",(0,i.jsx)(s.p,{children:"is returned."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"source"}),(0,i.jsx)(s.td,{children:"any"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsxs)(s.td,{children:["Any object with public ",(0,i.jsx)(s.code,{children:"x"})," and ",(0,i.jsx)(s.code,{children:"y"})," properties, such as a Game Object or Geometry object."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"targets"}),(0,i.jsxs)(s.td,{children:["Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),"> | Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),">"]}),(0,i.jsxs)(s.td,{children:["Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"}),">"]}),(0,i.jsx)(s.td,{children:"Yes"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),", ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),", ",(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})," - The target farthest from the given source point."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L493",children:"src/physics/arcade/ArcadePhysics.js#L493"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"getconfig",children:"getConfig"}),"\n",(0,i.jsx)(s.h3,{id:"instance-getconfig",children:"<instance> getConfig()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Creates the physics configuration for the current Scene."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeWorldConfig",children:"Phaser.Types.Physics.Arcade.ArcadeWorldConfig"})," - The physics configuration."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L181",children:"src/physics/arcade/ArcadePhysics.js#L181"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"moveto",children:"moveTo"}),"\n",(0,i.jsx)(s.h3,{id:"instance-movetogameobject-x-y-speed-maxtime",children:"<instance> moveTo(gameObject, x, y, [speed], [maxTime])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Move the given display object towards the x/y coordinates at a steady velocity."}),"\n",(0,i.jsx)(s.p,{children:"If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds."}),"\n",(0,i.jsx)(s.p,{children:"Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms."}),"\n",(0,i.jsx)(s.p,{children:"Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course."}),"\n",(0,i.jsx)(s.p,{children:"Note: The display object doesn't stop moving once it reaches the destination coordinates."}),"\n",(0,i.jsx)(s.p,{children:"Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"gameObject"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Any Game Object with an Arcade Physics body."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"x"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The x coordinate to move towards."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"y"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The y coordinate to move towards."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The speed it will move, in pixels per second (default is 60 pixels/sec)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"maxTime"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," number - The angle (in radians) that the object should be visually set to in order to match its new velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L548",children:"src/physics/arcade/ArcadePhysics.js#L548"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"movetoobject",children:"moveToObject"}),"\n",(0,i.jsx)(s.h3,{id:"instance-movetoobjectgameobject-destination-speed-maxtime",children:"<instance> moveToObject(gameObject, destination, [speed], [maxTime])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Move the given display object towards the destination object at a steady velocity."}),"\n",(0,i.jsx)(s.p,{children:"If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds."}),"\n",(0,i.jsx)(s.p,{children:"Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms."}),"\n",(0,i.jsx)(s.p,{children:"Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course."}),"\n",(0,i.jsx)(s.p,{children:"Note: The display object doesn't stop moving once it reaches the destination coordinates."}),"\n",(0,i.jsx)(s.p,{children:"Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"gameObject"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"Any Game Object with an Arcade Physics body."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"destination"}),(0,i.jsx)(s.td,{children:"object"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsxs)(s.td,{children:["Any object with public ",(0,i.jsx)(s.code,{children:"x"})," and ",(0,i.jsx)(s.code,{children:"y"})," properties, such as a Game Object or Geometry object."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The speed it will move, in pixels per second (default is 60 pixels/sec)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"maxTime"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"0"}),(0,i.jsx)(s.td,{children:"Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," number - The angle (in radians) that the object should be visually set to in order to match its new velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L585",children:"src/physics/arcade/ArcadePhysics.js#L585"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"nextcategory",children:"nextCategory"}),"\n",(0,i.jsx)(s.h3,{id:"instance-nextcategory",children:"<instance> nextCategory()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Returns the next available collision category."}),"\n",(0,i.jsx)(s.p,{children:"You can have a maximum of 32 categories."}),"\n",(0,i.jsx)(s.p,{children:"By default all bodies collide with all other bodies."}),"\n",(0,i.jsxs)(s.p,{children:["Use the ",(0,i.jsx)(s.code,{children:"Body.setCollisionCategory()"})," and"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"Body.setCollidesWith()"})," methods to change this."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," number - The next collision category."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L202",children:"src/physics/arcade/ArcadePhysics.js#L202"}),(0,i.jsx)(s.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"overlap",children:"overlap"}),"\n",(0,i.jsx)(s.h3,{id:"instance-overlapobject1-object2-overlapcallback-processcallback-callbackcontext",children:"<instance> overlap(object1, [object2], [overlapCallback], [processCallback], [callbackContext])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsxs)(s.p,{children:["Tests if Game Objects overlap. See ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#overlap",children:"Phaser.Physics.Arcade.World#overlap"})]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"object1"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"The first object or array of objects to check."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"object2"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["The second object or array of objects to check, or ",(0,i.jsx)(s.code,{children:"undefined"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"overlapCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"An optional callback function that is called if the objects overlap."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"processCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then ",(0,i.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,i.jsx)(s.code,{children:"true"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"callbackContext"}),(0,i.jsx)(s.td,{children:"*"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," boolean - True if at least one Game Object overlaps another."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L224",children:"src/physics/arcade/ArcadePhysics.js#L224"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"overlapcirc",children:"overlapCirc"}),"\n",(0,i.jsx)(s.h3,{id:"instance-overlapcircx-y-radius-includedynamic-includestatic",children:"<instance> overlapCirc(x, y, radius, [includeDynamic], [includeStatic])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This method will search the given circular area and return an array of all physics bodies that"}),"\n",(0,i.jsx)(s.p,{children:"overlap with it. It can return either Dynamic, Static bodies or a mixture of both."}),"\n",(0,i.jsx)(s.p,{children:"A body only has to intersect with the search area to be considered, it doesn't have to be fully"}),"\n",(0,i.jsx)(s.p,{children:"contained within it."}),"\n",(0,i.jsx)(s.p,{children:"If Arcade Physics is set to use the RTree (which it is by default) then the search is rather fast,"}),"\n",(0,i.jsx)(s.p,{children:"otherwise the search is O(N) for Dynamic Bodies."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"x"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The x coordinate of the center of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"y"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The y coordinate of the center of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"radius"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The radius of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"includeDynamic"}),(0,i.jsx)(s.td,{children:"boolean"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"true"}),(0,i.jsx)(s.td,{children:"Should the search include Dynamic Bodies?"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"includeStatic"}),(0,i.jsx)(s.td,{children:"boolean"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"false"}),(0,i.jsx)(s.td,{children:"Should the search include Static Bodies?"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),">, Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),"> - An array of bodies that overlap with the given area."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L677",children:"src/physics/arcade/ArcadePhysics.js#L677"}),(0,i.jsx)(s.br,{}),"\nSince: 3.21.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"overlaprect",children:"overlapRect"}),"\n",(0,i.jsx)(s.h3,{id:"instance-overlaprectx-y-width-height-includedynamic-includestatic",children:"<instance> overlapRect(x, y, width, height, [includeDynamic], [includeStatic])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This method will search the given rectangular area and return an array of all physics bodies that"}),"\n",(0,i.jsx)(s.p,{children:"overlap with it. It can return either Dynamic, Static bodies or a mixture of both."}),"\n",(0,i.jsx)(s.p,{children:"A body only has to intersect with the search area to be considered, it doesn't have to be fully"}),"\n",(0,i.jsx)(s.p,{children:"contained within it."}),"\n",(0,i.jsx)(s.p,{children:"If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,"}),"\n",(0,i.jsx)(s.p,{children:"otherwise the search is O(N) for Dynamic Bodies."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"x"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The top-left x coordinate of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"y"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The top-left y coordinate of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"width"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The width of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"height"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The height of the area to search within."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"includeDynamic"}),(0,i.jsx)(s.td,{children:"boolean"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"true"}),(0,i.jsx)(s.td,{children:"Should the search include Dynamic Bodies?"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"includeStatic"}),(0,i.jsx)(s.td,{children:"boolean"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"false"}),(0,i.jsx)(s.td,{children:"Should the search include Static Bodies?"})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),">, Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),"> - An array of bodies that overlap with the given area."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L650",children:"src/physics/arcade/ArcadePhysics.js#L650"}),(0,i.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"overlaptiles",children:"overlapTiles"}),"\n",(0,i.jsx)(s.h3,{id:"instance-overlaptilessprite-tiles-collidecallback-processcallback-callbackcontext",children:"<instance> overlapTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects."}),"\n",(0,i.jsxs)(s.p,{children:["You should generally use the ",(0,i.jsx)(s.code,{children:"overlap"})," method instead, with a Sprite vs. a Tilemap Layer, as that will perform"]}),"\n",(0,i.jsx)(s.p,{children:"tile filtering and culling for you, as well as handle the interesting face collision automatically."}),"\n",(0,i.jsx)(s.p,{children:"This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without"}),"\n",(0,i.jsx)(s.p,{children:"having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap"}),"\n",(0,i.jsx)(s.p,{children:"tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,"}),"\n",(0,i.jsx)(s.p,{children:"you should filter them before passing them to this method."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"sprite"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"tiles"}),(0,i.jsxs)(s.td,{children:["Array.<",(0,i.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"}),">"]}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{children:"An array of Tiles to check for collision against."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"collideCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"An optional callback function that is called if the objects overlap."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"processCallback"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,i.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,i.jsx)(s.code,{children:"true"}),"."]})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"callbackContext"}),(0,i.jsx)(s.td,{children:"any"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,i.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Fires:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_OVERLAP",children:"Phaser.Physics.Arcade.Events#event:TILE_OVERLAP"})]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L324",children:"src/physics/arcade/ArcadePhysics.js#L324"}),(0,i.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"pause",children:"pause"}),"\n",(0,i.jsx)(s.h3,{id:"instance-pause",children:"<instance> pause()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Pauses the simulation."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - The simulation."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L352",children:"src/physics/arcade/ArcadePhysics.js#L352"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"resume",children:"resume"}),"\n",(0,i.jsx)(s.h3,{id:"instance-resume",children:"<instance> resume()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Resumes the simulation (if paused)."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - The simulation."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L365",children:"src/physics/arcade/ArcadePhysics.js#L365"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"shutdown",children:"shutdown"}),"\n",(0,i.jsx)(s.h3,{id:"instance-shutdown",children:"<instance> shutdown()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"The Scene that owns this plugin is shutting down."}),"\n",(0,i.jsx)(s.p,{children:"We need to kill and reset all internal properties as well as stop listening to Scene events."}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L703",children:"src/physics/arcade/ArcadePhysics.js#L703"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"velocityfromangle",children:"velocityFromAngle"}),"\n",(0,i.jsx)(s.h3,{id:"instance-velocityfromangleangle-speed-vec2",children:"<instance> velocityFromAngle(angle, [speed], [vec2])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object."}),"\n",(0,i.jsx)(s.p,{children:"One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"angle"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The speed it will move, in pixels per second squared."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"vec2"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/math-vector2",children:"Phaser.Math.Vector2"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The Vector2 in which the x and y properties will be set to the calculated velocity."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/class/math-vector2",children:"Phaser.Math.Vector2"})," - The Vector2 that stores the velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L608",children:"src/physics/arcade/ArcadePhysics.js#L608"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"velocityfromrotation",children:"velocityFromRotation"}),"\n",(0,i.jsx)(s.h3,{id:"instance-velocityfromrotationrotation-speed-vec2",children:"<instance> velocityFromRotation(rotation, [speed], [vec2])"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object."}),"\n",(0,i.jsx)(s.p,{children:"One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,i.jsxs)(s.table,{children:[(0,i.jsx)(s.thead,{children:(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.th,{children:"name"}),(0,i.jsx)(s.th,{children:"type"}),(0,i.jsx)(s.th,{children:"optional"}),(0,i.jsx)(s.th,{children:"default"}),(0,i.jsx)(s.th,{children:"description"})]})}),(0,i.jsxs)(s.tbody,{children:[(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"rotation"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"No"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The angle in radians."})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"speed"}),(0,i.jsx)(s.td,{children:"number"}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{children:"60"}),(0,i.jsx)(s.td,{children:"The speed it will move, in pixels per second squared"})]}),(0,i.jsxs)(s.tr,{children:[(0,i.jsx)(s.td,{children:"vec2"}),(0,i.jsx)(s.td,{children:(0,i.jsx)(s.a,{href:"/api-documentation/class/math-vector2",children:"Phaser.Math.Vector2"})}),(0,i.jsx)(s.td,{children:"Yes"}),(0,i.jsx)(s.td,{}),(0,i.jsx)(s.td,{children:"The Vector2 in which the x and y properties will be set to the calculated velocity."})]})]})]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Returns:"})," ",(0,i.jsx)(s.a,{href:"/api-documentation/class/math-vector2",children:"Phaser.Math.Vector2"})," - The Vector2 that stores the velocity."]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L629",children:"src/physics/arcade/ArcadePhysics.js#L629"}),(0,i.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h1,{id:"private-methods",children:"Private Methods"}),"\n",(0,i.jsx)(s.h2,{id:"boot",children:"boot"}),"\n",(0,i.jsx)(s.h3,{id:"instance-boot",children:"<instance> boot()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This method is called automatically, only once, when the Scene is first created."}),"\n",(0,i.jsx)(s.p,{children:"Do not invoke it directly."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L105",children:"src/physics/arcade/ArcadePhysics.js#L105"}),(0,i.jsx)(s.br,{}),"\nSince: 3.5.1"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{}),"\n",(0,i.jsx)(s.h2,{id:"start",children:"start"}),"\n",(0,i.jsx)(s.h3,{id:"instance-start",children:"<instance> start()"}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Description:"})}),"\n",(0,i.jsx)(s.p,{children:"This method is called automatically by the Scene when it is starting up."}),"\n",(0,i.jsx)(s.p,{children:"It is responsible for creating local systems, properties and listening for Scene events."}),"\n",(0,i.jsx)(s.p,{children:"Do not invoke it directly."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,i.jsxs)(s.blockquote,{children:["\n",(0,i.jsxs)(s.p,{children:["Source: ",(0,i.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L121",children:"src/physics/arcade/ArcadePhysics.js#L121"}),(0,i.jsx)(s.br,{}),"\nSince: 3.5.0"]}),"\n"]}),"\n",(0,i.jsx)(s.hr,{})]})}function o(e={}){let{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:function(e,s,n){n.d(s,{R:()=>r,x:()=>d});var c=n(96540);let i={},t=c.createContext(i);function r(e){let s=c.useContext(t);return c.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),c.createElement(t.Provider,{value:s},e.children)}}}]);
"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["96079"],{41338:function(e,t,s){s.r(t),s.d(t,{metadata:()=>n,default:()=>l,frontMatter:()=>o,contentTitle:()=>c,toc:()=>d,assets:()=>a});var n=JSON.parse('{"id":"phaser-editor/scene-editor/script-node/script-node-class","title":"The ScriptNode class","description":"When you create an instance of a ScriptNode, the scene compiler generates a code like this:","source":"@site/docs/phaser-editor/scene-editor/script-node/script-node-class.md","sourceDirName":"phaser-editor/scene-editor/script-node","slug":"/phaser-editor/scene-editor/script-node/script-node-class","permalink":"/phaser-editor/scene-editor/script-node/script-node-class","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"slug":"script-node-class","title":"The ScriptNode class"},"sidebar":"PhaserEditorSidebar","previous":{"title":"Creating a Script Node","permalink":"/phaser-editor/scene-editor/script-node/script-node-create"},"next":{"title":"The Core scripts project","permalink":"/phaser-editor/scene-editor/script-node/script-node-basic-scripts-project"}}'),r=s(74848),i=s(28453);let o={slug:"script-node-class",title:"The ScriptNode class"},c,a={},d=[{value:"The parent",id:"the-parent",level:2},{value:"The children",id:"the-children",level:2},{value:"The events",id:"the-events",level:2},{value:"The action methods",id:"the-action-methods",level:2},{value:"The action\u2019s target",id:"the-actions-target",level:2},{value:"Custom action script node",id:"custom-action-script-node",level:2}];function h(e){let t={a:"a",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:["When you create an instance of a ScriptNode, the ",(0,r.jsx)(t.a,{href:"../scene-compiler",children:"scene compiler"})," generates a code like this:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"new ScriptNode(parent);\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It means it creates an instance of the ",(0,r.jsx)(t.code,{children:"ScriptNode"})," class. But this class is not part of the Phaser API, it is a class you should code yourself."]}),"\n",(0,r.jsx)(t.p,{children:"The protocol of this class is simple, it needs a constructor that receives a parent argument. Something like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"class ScriptNode {\n\n   constructor(parent) {\n   }\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"It is simple, but if you need to, you can create a prefab with more features, like handling children, events, etc\u2026"}),"\n",(0,r.jsxs)(t.p,{children:["The good news is that this class is included in the Phaser Editor project templates. If your project is not based on a template, you can install it from the ",(0,r.jsx)(t.code,{children:"@phaserjs/editor-scripts-core"})," script library. ",(0,r.jsx)(t.a,{href:"script-node-libraries",children:"Learn more about the script libraries"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Also, Phaser Editor can generate the default implementation of this class for you, with the basic features:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["In the ",(0,r.jsx)(t.a,{href:"../../workbench/files-view",children:"Files view"}),", select the folder when you want to add the class file."]}),"\n",(0,r.jsxs)(t.li,{children:["Open the ",(0,r.jsx)(t.a,{href:"../../workbench/command-palette",children:"Command Palette"})," (",(0,r.jsx)(t.code,{children:"Ctrl+K"}),") and search for ",(0,r.jsx)(t.code,{children:"script"}),"."]}),"\n",(0,r.jsx)(t.li,{children:"Select the command with the desired format (TypeScript, JavaScript, ES modules,\u2026)."}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Execute"})," the command and it generates the class file in the selected folder."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/script-node-create-script-node-class-1-20230323.webp",alt:"Create ScriptNode class commands."})}),"\n",(0,r.jsx)(t.p,{children:"This built-in class the editor provides contains a couple of features:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Keeps a reference to the scene, the game object, and the parent."}),"\n",(0,r.jsx)(t.li,{children:"Manages an array of the children nodes."}),"\n",(0,r.jsxs)(t.li,{children:["Registers listeners to the scene and game object for implementing the ",(0,r.jsx)(t.strong,{children:"awake"}),", ",(0,r.jsx)(t.strong,{children:"start"}),", ",(0,r.jsx)(t.strong,{children:"update"}),", and ",(0,r.jsx)(t.strong,{children:"destroy"})," events. It follows the same logic as the ",(0,r.jsx)(t.a,{href:"../user-components/user-components-super-class",children:"User Components events"}),"."]}),"\n",(0,r.jsx)(t.li,{children:"Provides an interface for \u201Caction nodes\u201D."}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"the-parent",children:"The parent"}),"\n",(0,r.jsxs)(t.p,{children:["When a new instance of the ",(0,r.jsx)(t.code,{children:"ScriptNode"})," class is created, it receives a parent node as an argument. This parent could be a scene, a game object, or another script node."]}),"\n",(0,r.jsxs)(t.p,{children:["The script node instance keeps a reference to the parent, but also keeps a reference to the game object and the scene. Sure, if the node is added to a scene, the game object reference is not updated, it keeps ",(0,r.jsx)(t.code,{children:"undefined"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Related to the parent, the class provides the following properties:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"parent()"}),": it\u2019s type is ",(0,r.jsx)(t.code,{children:"Phaser.Scene | Phaser.GameObjects.GameObject | ScriptNode"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"gameObject()"}),": it\u2019s type is ",(0,r.jsx)(t.code,{children:"Phaser.GameObjects.GameObject | undefined"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"scene()"}),": it\u2019s type is ",(0,r.jsx)(t.code,{children:"Phaser.Scene"}),"."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"the-children",children:"The children"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"ScriptNode"})," class has an array of nodes for keeping the children. This array is updated when a new node is created. It also provides some related methods:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"children ()"}),": A property for iterating the children."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"add()"}),": A method for adding new children. This method is called automatically when a new child is created."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"the-events",children:"The events"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"ScriptNode"})," class provides a couple of methods for handling special events that may help you implement the behaviors. It works just like the ",(0,r.jsx)(t.a,{href:"../user-components/user-components-super-class",children:"User Components events"}),". The methods are:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"awake()"}),": It is called when all the objects of the scene are created. The values of the user properties (prefab) will be available at this time, so you can override this method for making computations that require the value of the properties. It works like the ",(0,r.jsx)(t.a,{href:"../user-components/user-components-awake-event",children:"UserComponent \u201Cawake\u201D method"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"start()"}),": It is called the first time the scene updates."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"update()"}),": It is called each time the scene updates."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"destroy()"}),": It is called when the game object is destroyed or the scene is shut down."]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"the-action-methods",children:"The action methods"}),"\n",(0,r.jsx)(t.p,{children:"We find it convenient to establish a protocol for action script nodes. An action script is a script node that will execute a certain task. For that purpose, the class provides the following methods:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"execute()"}),": Contains the code of the action."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"executeChildren()"}),": Executes the children."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"In the next chapter, we mention a project with basic node implementations that you can include in your game. These scripts provide a protocol or style you can adopt for your game."}),"\n",(0,r.jsx)(t.h2,{id:"the-actions-target",children:"The action\u2019s target"}),"\n",(0,r.jsx)(t.p,{children:"Most of the action nodes modify or read the game object of the node. This is fine for a lot of cases, but a bit limited. Let\u2019s see an example."}),"\n",(0,r.jsx)(t.p,{children:"You want to make a collider between a player object and a list of coin objects and destroy the coin when the player touches it:"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-script-node-target-action-game-20240109.webp",alt:"The scene for collecting coins"})}),"\n",(0,r.jsxs)(t.p,{children:["We have a ",(0,r.jsx)(t.strong,{children:"Make Collider Action"})," node that you can add to the player. This node has a parameter to select the other object you want to collide with. In this case, it is a container with the coins:"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-script-node-demo-collider-node-20240109.webp",alt:"Make collider node."}),(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-script-node-demo-collider-node-props-20240109.webp",alt:"Make collider node properties"})]}),"\n",(0,r.jsx)(t.p,{children:"When the collision happens, the collider node executes the children and passes the two objects as arguments. In the first argument goes the player, and in the second argument goes the coin."}),"\n",(0,r.jsxs)(t.p,{children:["So, we add ",(0,r.jsx)(t.strong,{children:"Destroy Object Action"})," to the collider node. This node is an action to destroy an object. By default, it destroys the game object associated with it: the player. But we want to destroy the coin, not the player. So we need to change the target of the destroy action from the game object to the second argument."]}),"\n",(0,r.jsxs)(t.p,{children:["To do this, we add the ",(0,r.jsx)(t.strong,{children:"Action Target Config"})," user component to the destroy object action, and set the ",(0,r.jsx)(t.strong,{children:"Target"})," to ",(0,r.jsx)(t.strong,{children:"ARG_2"}),". The destroy action then will get the second argument and destroy it."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-script-node-collider-demo-destroy-action-20240109.webp",alt:"The destroy action node"}),(0,r.jsx)(t.img,{src:"https://cdn.phaser.io/editor-docs/scene-editor-script-node-collider-demo-destroy-action-properties-20240109.webp",alt:"The properties of the destroy action"})]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.strong,{children:"Target"})," parameter shows an array of options, ",(0,r.jsx)(t.strong,{children:"GAME_OBJECT"})," (default), ",(0,r.jsx)(t.strong,{children:"ARG_1"}),", \u2026, ",(0,r.jsx)(t.strong,{children:"ARG_8"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["In addition to the ",(0,r.jsx)(t.strong,{children:"Target"}),", you can set the ",(0,r.jsx)(t.strong,{children:"Target Name"})," of the action. This name is only about syntax sugar and makes the node more readable in the Outline view. Look in the previous screenshot, the node starts with the value of ",(0,r.jsx)(t.strong,{children:"Target"})," plus the ",(0,r.jsx)(t.strong,{children:"Target Name"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"custom-action-script-node",children:"Custom action script node"}),"\n",(0,r.jsxs)(t.p,{children:["Making a new action node is very simple. Just create a prefab of a ",(0,r.jsx)(t.strong,{children:"Script Node"}),", and implement the ",(0,r.jsx)(t.code,{children:"execute()"})," method. If you want to support the ",(0,r.jsx)(t.strong,{children:"Action Target Config"})," component, you can use the ",(0,r.jsx)(t.code,{children:"ScriptNode.getActionTargetObject()"})," utility method:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"execute(...args: any[]) {\n\n   const obj = this.getActionTargetObject(args);\n\n   obj.doSomething();\n}\n"})}),"\n",(0,r.jsx)(t.p,{children:"That utility method does the following:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Check if the ",(0,r.jsx)(t.strong,{children:"Action Target Config"})," user component is present in the node. If it is present and has a target configured to return an argument, then returns the right argument."]}),"\n",(0,r.jsx)(t.li,{children:"Else, it returns the node\u2019s game object."}),"\n"]})]})}function l(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:function(e,t,s){s.d(t,{R:()=>o,x:()=>c});var n=s(96540);let r={},i=n.createContext(r);function o(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);
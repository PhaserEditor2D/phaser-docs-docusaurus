"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["96578"],{25300:function(e,s,n){n.r(s),n.d(s,{metadata:()=>r,default:()=>o,frontMatter:()=>l,contentTitle:()=>t,toc:()=>a,assets:()=>d});var r=JSON.parse('{"id":"class/Phaser.Physics.Arcade.World","title":"World","description":"Phaser.Physics.Arcade.World","source":"@site/api-documentation_versioned_docs/version-3.87.0/class/Phaser.Physics.Arcade.World.md","sourceDirName":"class","slug":"/class/physics-arcade-world","permalink":"/api-documentation/class/physics-arcade-world","draft":false,"unlisted":false,"tags":[],"version":"3.87.0","frontMatter":{"visibility":"public","slug":"physics-arcade-world","title":"World","description":"Phaser.Physics.Arcade.World","seoTitle":"Phaser.Physics.Arcade.World","seoDescription":"Phaser v3.87.0 Documentation for Phaser.Physics.Arcade.World","ogImage":null},"sidebar":"PhaserApiSidebar","previous":{"title":"StaticGroup","permalink":"/api-documentation/class/physics-arcade-staticgroup"},"next":{"title":"BodyBounds","permalink":"/api-documentation/class/physics-matter-bodybounds"}}'),c=n(74848),i=n(28453);let l={visibility:"public",slug:"physics-arcade-world",title:"World",description:"Phaser.Physics.Arcade.World",seoTitle:"Phaser.Physics.Arcade.World",seoDescription:"Phaser v3.87.0 Documentation for Phaser.Physics.Arcade.World",ogImage:null},t,d={},a=[{value:"bodies",id:"bodies",level:2},{value:"bodies: Phaser.Structs.Set.&lt;Phaser.Physics.Arcade.Body&gt;",id:"bodies-phaserstructssetphaserphysicsarcadebody",level:3},{value:"bounds",id:"bounds",level:2},{value:"bounds: Phaser.Geom.Rectangle",id:"bounds-phasergeomrectangle",level:3},{value:"checkCollision",id:"checkcollision",level:2},{value:"checkCollision: Phaser.Types.Physics.Arcade.CheckCollisionObject",id:"checkcollision-phasertypesphysicsarcadecheckcollisionobject",level:3},{value:"colliders",id:"colliders",level:2},{value:"colliders: Phaser.Structs.ProcessQueue.&lt;Phaser.Physics.Arcade.Collider&gt;",id:"colliders-phaserstructsprocessqueuephaserphysicsarcadecollider",level:3},{value:"debugGraphic",id:"debuggraphic",level:2},{value:"debugGraphic: Phaser.GameObjects.Graphics",id:"debuggraphic-phasergameobjectsgraphics",level:3},{value:"defaults",id:"defaults",level:2},{value:"defaults: Phaser.Types.Physics.Arcade.ArcadeWorldDefaults",id:"defaults-phasertypesphysicsarcadearcadeworlddefaults",level:3},{value:"drawDebug",id:"drawdebug",level:2},{value:"drawDebug: boolean",id:"drawdebug-boolean",level:3},{value:"fixedStep",id:"fixedstep",level:2},{value:"fixedStep: boolean",id:"fixedstep-boolean",level:3},{value:"forceX",id:"forcex",level:2},{value:"forceX: boolean",id:"forcex-boolean",level:3},{value:"fps",id:"fps",level:2},{value:"fps: number",id:"fps-number",level:3},{value:"gravity",id:"gravity",level:2},{value:"gravity: Phaser.Math.Vector2",id:"gravity-phasermathvector2",level:3},{value:"isPaused",id:"ispaused",level:2},{value:"isPaused: boolean",id:"ispaused-boolean",level:3},{value:"maxEntries",id:"maxentries",level:2},{value:"maxEntries: number",id:"maxentries-number",level:3},{value:"OVERLAP_BIAS",id:"overlap_bias",level:2},{value:"OVERLAP_BIAS: number",id:"overlap_bias-number",level:3},{value:"pendingDestroy",id:"pendingdestroy",level:2},{value:"pendingDestroy: Phaser.Structs.Set.&lt;(Phaser.Physics.Arcade.Body | Phaser.Physics.Arcade.StaticBody)&gt;",id:"pendingdestroy-phaserstructssetphaserphysicsarcadebody--phaserphysicsarcadestaticbody",level:3},{value:"scene",id:"scene",level:2},{value:"scene: Phaser.Scene",id:"scene-phaserscene",level:3},{value:"staticBodies",id:"staticbodies",level:2},{value:"staticBodies: Phaser.Structs.Set.&lt;Phaser.Physics.Arcade.StaticBody&gt;",id:"staticbodies-phaserstructssetphaserphysicsarcadestaticbody",level:3},{value:"staticTree",id:"statictree",level:2},{value:"staticTree: Phaser.Structs.RTree",id:"statictree-phaserstructsrtree",level:3},{value:"stepsLastFrame",id:"stepslastframe",level:2},{value:"stepsLastFrame: number",id:"stepslastframe-number",level:3},{value:"TILE_BIAS",id:"tile_bias",level:2},{value:"TILE_BIAS: number",id:"tile_bias-number",level:3},{value:"tileFilterOptions",id:"tilefilteroptions",level:2},{value:"tileFilterOptions: Phaser.Types.Tilemaps.FilteringOptions",id:"tilefilteroptions-phasertypestilemapsfilteringoptions",level:3},{value:"timeScale",id:"timescale",level:2},{value:"timeScale: number",id:"timescale-number",level:3},{value:"tree",id:"tree",level:2},{value:"tree: Phaser.Structs.RTree",id:"tree-phaserstructsrtree",level:3},{value:"treeMinMax",id:"treeminmax",level:2},{value:"treeMinMax: Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax",id:"treeminmax-phasertypesphysicsarcadearcadeworldtreeminmax",level:3},{value:"useTree",id:"usetree",level:2},{value:"useTree: boolean",id:"usetree-boolean",level:3},{value:"_category",id:"_category",level:2},{value:"_category: number",id:"_category-number",level:3},{value:"_elapsed",id:"_elapsed",level:2},{value:"_elapsed: number",id:"_elapsed-number",level:3},{value:"_frameTime",id:"_frametime",level:2},{value:"_frameTime: number",id:"_frametime-number",level:3},{value:"_frameTimeMS",id:"_frametimems",level:2},{value:"_frameTimeMS: number",id:"_frametimems-number",level:3},{value:"_tempMatrix",id:"_tempmatrix",level:2},{value:"_tempMatrix: Phaser.GameObjects.Components.TransformMatrix",id:"_tempmatrix-phasergameobjectscomponentstransformmatrix",level:3},{value:"_tempMatrix2",id:"_tempmatrix2",level:2},{value:"_tempMatrix2: Phaser.GameObjects.Components.TransformMatrix",id:"_tempmatrix2-phasergameobjectscomponentstransformmatrix",level:3},{value:"_total",id:"_total",level:2},{value:"_total: number",id:"_total-number",level:3},{value:"add",id:"add",level:2},{value:"&lt;instance&gt; add(body)",id:"instance-addbody",level:3},{value:"addCollider",id:"addcollider",level:2},{value:"&lt;instance&gt; addCollider(object1, object2, [collideCallback], [processCallback], [callbackContext])",id:"instance-addcolliderobject1-object2-collidecallback-processcallback-callbackcontext",level:3},{value:"addListener",id:"addlistener",level:2},{value:"&lt;instance&gt; addListener(event, fn, [context])",id:"instance-addlistenerevent-fn-context",level:3},{value:"addOverlap",id:"addoverlap",level:2},{value:"&lt;instance&gt; addOverlap(object1, object2, [collideCallback], [processCallback], [callbackContext])",id:"instance-addoverlapobject1-object2-collidecallback-processcallback-callbackcontext",level:3},{value:"canCollide",id:"cancollide",level:2},{value:"&lt;instance&gt; canCollide(body1, body2)",id:"instance-cancollidebody1-body2",level:3},{value:"circleBodyIntersects",id:"circlebodyintersects",level:2},{value:"&lt;instance&gt; circleBodyIntersects(circle, body)",id:"instance-circlebodyintersectscircle-body",level:3},{value:"collide",id:"collide",level:2},{value:"&lt;instance&gt; collide(object1, [object2], [collideCallback], [processCallback], [callbackContext])",id:"instance-collideobject1-object2-collidecallback-processcallback-callbackcontext",level:3},{value:"collideSpriteVsTilemapLayer",id:"collidespritevstilemaplayer",level:2},{value:"&lt;instance&gt; collideSpriteVsTilemapLayer(sprite, tilemapLayer, [collideCallback], [processCallback], [callbackContext], [overlapOnly])",id:"instance-collidespritevstilemaplayersprite-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideTiles",id:"collidetiles",level:2},{value:"&lt;instance&gt; collideTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])",id:"instance-collidetilessprite-tiles-collidecallback-processcallback-callbackcontext",level:3},{value:"computeAngularVelocity",id:"computeangularvelocity",level:2},{value:"&lt;instance&gt; computeAngularVelocity(body, delta)",id:"instance-computeangularvelocitybody-delta",level:3},{value:"computeVelocity",id:"computevelocity",level:2},{value:"&lt;instance&gt; computeVelocity(body, delta)",id:"instance-computevelocitybody-delta",level:3},{value:"createDebugGraphic",id:"createdebuggraphic",level:2},{value:"&lt;instance&gt; createDebugGraphic()",id:"instance-createdebuggraphic",level:3},{value:"destroy",id:"destroy",level:2},{value:"&lt;instance&gt; destroy()",id:"instance-destroy",level:3},{value:"disable",id:"disable",level:2},{value:"&lt;instance&gt; disable(object)",id:"instance-disableobject",level:3},{value:"disableBody",id:"disablebody",level:2},{value:"&lt;instance&gt; disableBody(body)",id:"instance-disablebodybody",level:3},{value:"emit",id:"emit",level:2},{value:"&lt;instance&gt; emit(event, [args])",id:"instance-emitevent-args",level:3},{value:"enable",id:"enable",level:2},{value:"&lt;instance&gt; enable(object, [bodyType])",id:"instance-enableobject-bodytype",level:3},{value:"enableBody",id:"enablebody",level:2},{value:"&lt;instance&gt; enableBody(object, [bodyType])",id:"instance-enablebodyobject-bodytype",level:3},{value:"eventNames",id:"eventnames",level:2},{value:"&lt;instance&gt; eventNames()",id:"instance-eventnames",level:3},{value:"intersects",id:"intersects",level:2},{value:"&lt;instance&gt; intersects(body1, body2)",id:"instance-intersectsbody1-body2",level:3},{value:"listenerCount",id:"listenercount",level:2},{value:"&lt;instance&gt; listenerCount(event)",id:"instance-listenercountevent",level:3},{value:"listeners",id:"listeners",level:2},{value:"&lt;instance&gt; listeners(event)",id:"instance-listenersevent",level:3},{value:"off",id:"off",level:2},{value:"&lt;instance&gt; off(event, [fn], [context], [once])",id:"instance-offevent-fn-context-once",level:3},{value:"on",id:"on",level:2},{value:"&lt;instance&gt; on(event, fn, [context])",id:"instance-onevent-fn-context",level:3},{value:"once",id:"once",level:2},{value:"&lt;instance&gt; once(event, fn, [context])",id:"instance-onceevent-fn-context",level:3},{value:"overlap",id:"overlap",level:2},{value:"&lt;instance&gt; overlap(object1, [object2], [overlapCallback], [processCallback], [callbackContext])",id:"instance-overlapobject1-object2-overlapcallback-processcallback-callbackcontext",level:3},{value:"overlapTiles",id:"overlaptiles",level:2},{value:"&lt;instance&gt; overlapTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])",id:"instance-overlaptilessprite-tiles-collidecallback-processcallback-callbackcontext",level:3},{value:"pause",id:"pause",level:2},{value:"&lt;instance&gt; pause()",id:"instance-pause",level:3},{value:"postUpdate",id:"postupdate",level:2},{value:"&lt;instance&gt; postUpdate()",id:"instance-postupdate",level:3},{value:"remove",id:"remove",level:2},{value:"&lt;instance&gt; remove(body)",id:"instance-removebody",level:3},{value:"removeAllListeners",id:"removealllisteners",level:2},{value:"&lt;instance&gt; removeAllListeners([event])",id:"instance-removealllistenersevent",level:3},{value:"removeCollider",id:"removecollider",level:2},{value:"&lt;instance&gt; removeCollider(collider)",id:"instance-removecollidercollider",level:3},{value:"removeListener",id:"removelistener",level:2},{value:"&lt;instance&gt; removeListener(event, [fn], [context], [once])",id:"instance-removelistenerevent-fn-context-once",level:3},{value:"resume",id:"resume",level:2},{value:"&lt;instance&gt; resume()",id:"instance-resume",level:3},{value:"separate",id:"separate",level:2},{value:"&lt;instance&gt; separate(body1, body2, [processCallback], [callbackContext], [overlapOnly])",id:"instance-separatebody1-body2-processcallback-callbackcontext-overlaponly",level:3},{value:"separateCircle",id:"separatecircle",level:2},{value:"&lt;instance&gt; separateCircle(body1, body2, [overlapOnly])",id:"instance-separatecirclebody1-body2-overlaponly",level:3},{value:"setBounds",id:"setbounds",level:2},{value:"&lt;instance&gt; setBounds(x, y, width, height, [checkLeft], [checkRight], [checkUp], [checkDown])",id:"instance-setboundsx-y-width-height-checkleft-checkright-checkup-checkdown",level:3},{value:"setBoundsCollision",id:"setboundscollision",level:2},{value:"&lt;instance&gt; setBoundsCollision([left], [right], [up], [down])",id:"instance-setboundscollisionleft-right-up-down",level:3},{value:"setFPS",id:"setfps",level:2},{value:"&lt;instance&gt; setFPS(framerate)",id:"instance-setfpsframerate",level:3},{value:"shutdown",id:"shutdown",level:2},{value:"&lt;instance&gt; shutdown()",id:"instance-shutdown",level:3},{value:"singleStep",id:"singlestep",level:2},{value:"&lt;instance&gt; singleStep()",id:"instance-singlestep",level:3},{value:"step",id:"step",level:2},{value:"&lt;instance&gt; step(delta)",id:"instance-stepdelta",level:3},{value:"update",id:"update",level:2},{value:"&lt;instance&gt; update(time, delta)",id:"instance-updatetime-delta",level:3},{value:"updateMotion",id:"updatemotion",level:2},{value:"&lt;instance&gt; updateMotion(body, delta)",id:"instance-updatemotionbody-delta",level:3},{value:"wrap",id:"wrap",level:2},{value:"&lt;instance&gt; wrap(object, [padding])",id:"instance-wrapobject-padding",level:3},{value:"wrapArray",id:"wraparray",level:2},{value:"&lt;instance&gt; wrapArray(objects, [padding])",id:"instance-wraparrayobjects-padding",level:3},{value:"wrapObject",id:"wrapobject",level:2},{value:"&lt;instance&gt; wrapObject(object, [padding])",id:"instance-wrapobjectobject-padding",level:3},{value:"collideGroupVsGroup",id:"collidegroupvsgroup",level:2},{value:"&lt;instance&gt; collideGroupVsGroup(group1, group2, [collideCallback], [processCallback], [callbackContext], overlapOnly)",id:"instance-collidegroupvsgroupgroup1-group2-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideGroupVsTilemapLayer",id:"collidegroupvstilemaplayer",level:2},{value:"&lt;instance&gt; collideGroupVsTilemapLayer(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)",id:"instance-collidegroupvstilemaplayergroup-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideHandler",id:"collidehandler",level:2},{value:"&lt;instance&gt; collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)",id:"instance-collidehandlerobject1-object2-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideObjects",id:"collideobjects",level:2},{value:"&lt;instance&gt; collideObjects(object1, [object2], collideCallback, processCallback, callbackContext, overlapOnly)",id:"instance-collideobjectsobject1-object2-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideSpriteVsGroup",id:"collidespritevsgroup",level:2},{value:"&lt;instance&gt; collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)",id:"instance-collidespritevsgroupsprite-group-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideSpriteVsSprite",id:"collidespritevssprite",level:2},{value:"&lt;instance&gt; collideSpriteVsSprite(sprite1, sprite2, [collideCallback], [processCallback], [callbackContext], overlapOnly)",id:"instance-collidespritevsspritesprite1-sprite2-collidecallback-processcallback-callbackcontext-overlaponly",level:3},{value:"collideSpriteVsTilesHandler",id:"collidespritevstileshandler",level:2},{value:"&lt;instance&gt; collideSpriteVsTilesHandler(sprite, tilemapLayer, [collideCallback], [processCallback], [callbackContext], [overlapOnly], [isLayer])",id:"instance-collidespritevstileshandlersprite-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly-islayer",level:3}];function h(e){let s={a:"a",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(s.p,{children:"The Arcade Physics World."}),"\n",(0,c.jsx)(s.p,{children:"The World is responsible for creating, managing, colliding and updating all of the bodies within it."}),"\n",(0,c.jsxs)(s.p,{children:["An instance of the World belongs to a Phaser.Scene and is accessed via the property ",(0,c.jsx)(s.code,{children:"physics.world"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Constructor"})}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.code,{children:"new World(scene, config)"})}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"scene"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/scene",children:"Phaser.Scene"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Scene to which this World instance belongs."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"config"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeWorldConfig",children:"Phaser.Types.Physics.Arcade.ArcadeWorldConfig"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"An Arcade Physics Configuration object."})]})]})]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Scope"}),": static"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Extends"})}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter",children:"Phaser.Events.EventEmitter"})}),"\n"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L39",children:"src/physics/arcade/World.js#L39"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.h1,{id:"public-members",children:"Public Members"}),"\n",(0,c.jsx)(s.h2,{id:"bodies",children:"bodies"}),"\n",(0,c.jsx)(s.h3,{id:"bodies-phaserstructssetphaserphysicsarcadebody",children:"bodies: Phaser.Structs.Set.<Phaser.Physics.Arcade.Body>"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Dynamic Bodies in this simulation."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L75",children:"src/physics/arcade/World.js#L75"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"bounds",children:"bounds"}),"\n",(0,c.jsxs)(s.h3,{id:"bounds-phasergeomrectangle",children:["bounds: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/geom-rectangle",children:"Phaser.Geom.Rectangle"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"A boundary constraining Bodies."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L120",children:"src/physics/arcade/World.js#L120"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"checkcollision",children:"checkCollision"}),"\n",(0,c.jsxs)(s.h3,{id:"checkcollision-phasertypesphysicsarcadecheckcollisionobject",children:["checkCollision: ",(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#CheckCollisionObject",children:"Phaser.Types.Physics.Arcade.CheckCollisionObject"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The boundary edges that Bodies can collide with."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L134",children:"src/physics/arcade/World.js#L134"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"colliders",children:"colliders"}),"\n",(0,c.jsx)(s.h3,{id:"colliders-phaserstructsprocessqueuephaserphysicsarcadecollider",children:"colliders: Phaser.Structs.ProcessQueue.<Phaser.Physics.Arcade.Collider>"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"This simulation's collision processors."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L102",children:"src/physics/arcade/World.js#L102"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"debuggraphic",children:"debugGraphic"}),"\n",(0,c.jsxs)(s.h3,{id:"debuggraphic-phasergameobjectsgraphics",children:["debugGraphic: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-graphics",children:"Phaser.GameObjects.Graphics"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The graphics object drawing the debug display."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L293",children:"src/physics/arcade/World.js#L293"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"defaults",children:"defaults"}),"\n",(0,c.jsxs)(s.h3,{id:"defaults-phasertypesphysicsarcadearcadeworlddefaults",children:["defaults: ",(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeWorldDefaults",children:"Phaser.Types.Physics.Arcade.ArcadeWorldDefaults"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Default debug display settings for new Bodies."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L302",children:"src/physics/arcade/World.js#L302"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"drawdebug",children:"drawDebug"}),"\n",(0,c.jsx)(s.h3,{id:"drawdebug-boolean",children:"drawDebug: boolean"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Enables the debug display."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L283",children:"src/physics/arcade/World.js#L283"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"fixedstep",children:"fixedStep"}),"\n",(0,c.jsx)(s.h3,{id:"fixedstep-boolean",children:"fixedStep: boolean"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Should Physics use a fixed update time-step (true) or sync to the render fps (false)?."}),"\n",(0,c.jsx)(s.p,{children:"False value of this property disables fps and timeScale properties."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L161",children:"src/physics/arcade/World.js#L161"}),(0,c.jsx)(s.br,{}),"\nSince: 3.23.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"forcex",children:"forceX"}),"\n",(0,c.jsx)(s.h3,{id:"forcex-boolean",children:"forceX: boolean"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Always separate overlapping Bodies horizontally before vertically."}),"\n",(0,c.jsx)(s.p,{children:"False (the default) means Bodies are first separated on the axis of greater gravity, or the vertical axis if neither is greater."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L251",children:"src/physics/arcade/World.js#L251"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"fps",children:"fps"}),"\n",(0,c.jsx)(s.h3,{id:"fps-number",children:"fps: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The number of physics steps to be taken per second."}),"\n",(0,c.jsxs)(s.p,{children:["This property is read-only. Use the ",(0,c.jsx)(s.code,{children:"setFPS"})," method to modify it at run-time."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L148",children:"src/physics/arcade/World.js#L148"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"gravity",children:"gravity"}),"\n",(0,c.jsxs)(s.h3,{id:"gravity-phasermathvector2",children:["gravity: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/math-vector2",children:"Phaser.Math.Vector2"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Acceleration of Bodies due to gravity, in pixels per second."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L111",children:"src/physics/arcade/World.js#L111"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"ispaused",children:"isPaused"}),"\n",(0,c.jsx)(s.h3,{id:"ispaused-boolean",children:"isPaused: boolean"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Whether the simulation advances with the game loop."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L262",children:"src/physics/arcade/World.js#L262"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"maxentries",children:"maxEntries"}),"\n",(0,c.jsx)(s.h3,{id:"maxentries-number",children:"maxEntries: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The maximum number of items per node on the RTree."}),"\n",(0,c.jsxs)(s.p,{children:["This is ignored if ",(0,c.jsx)(s.code,{children:"useTree"})," is ",(0,c.jsx)(s.code,{children:"false"}),". If you have a large number of bodies in"]}),"\n",(0,c.jsx)(s.p,{children:"your world then you may find search performance improves by increasing this value,"}),"\n",(0,c.jsx)(s.p,{children:"to allow more items per node and less node division."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L318",children:"src/physics/arcade/World.js#L318"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"overlap_bias",children:"OVERLAP_BIAS"}),"\n",(0,c.jsx)(s.h3,{id:"overlap_bias-number",children:"OVERLAP_BIAS: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["The maximum absolute difference of a Body's per-step velocity and its overlap with another Body that will result in separation on ",(0,c.jsx)(s.em,{children:"each axis"}),"."]}),"\n",(0,c.jsx)(s.p,{children:"Larger values favor separation."}),"\n",(0,c.jsx)(s.p,{children:"Smaller values favor no separation."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L226",children:"src/physics/arcade/World.js#L226"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"pendingdestroy",children:"pendingDestroy"}),"\n",(0,c.jsxs)(s.h3,{id:"pendingdestroy-phaserstructssetphaserphysicsarcadebody--phaserphysicsarcadestaticbody",children:["pendingDestroy: Phaser.Structs.Set.<(Phaser.Physics.Arcade.Body | ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"}),")>"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Static Bodies marked for deletion."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L93",children:"src/physics/arcade/World.js#L93"}),(0,c.jsx)(s.br,{}),"\nSince: 3.1.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"scene",children:"scene"}),"\n",(0,c.jsxs)(s.h3,{id:"scene-phaserscene",children:["scene: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/scene",children:"Phaser.Scene"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The Scene this simulation belongs to."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L66",children:"src/physics/arcade/World.js#L66"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"staticbodies",children:"staticBodies"}),"\n",(0,c.jsx)(s.h3,{id:"staticbodies-phaserstructssetphaserphysicsarcadestaticbody",children:"staticBodies: Phaser.Structs.Set.<Phaser.Physics.Arcade.StaticBody>"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Static Bodies in this simulation."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L84",children:"src/physics/arcade/World.js#L84"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"statictree",children:"staticTree"}),"\n",(0,c.jsxs)(s.h3,{id:"statictree-phaserstructsrtree",children:["staticTree: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/structs-rtree",children:"Phaser.Structs.RTree"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The spatial index of Static Bodies."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L365",children:"src/physics/arcade/World.js#L365"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"stepslastframe",children:"stepsLastFrame"}),"\n",(0,c.jsx)(s.h3,{id:"stepslastframe-number",children:"stepsLastFrame: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The number of steps that took place in the last frame."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L202",children:"src/physics/arcade/World.js#L202"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"tile_bias",children:"TILE_BIAS"}),"\n",(0,c.jsx)(s.h3,{id:"tile_bias-number",children:"TILE_BIAS: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["The maximum absolute value of a Body's overlap with a tile that will result in separation on ",(0,c.jsx)(s.em,{children:"each axis"}),"."]}),"\n",(0,c.jsx)(s.p,{children:"Larger values favor separation."}),"\n",(0,c.jsx)(s.p,{children:"Smaller values favor no separation."}),"\n",(0,c.jsx)(s.p,{children:"The optimum value may be similar to the tile size."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L238",children:"src/physics/arcade/World.js#L238"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"tilefilteroptions",children:"tileFilterOptions"}),"\n",(0,c.jsxs)(s.h3,{id:"tilefilteroptions-phasertypestilemapsfilteringoptions",children:["tileFilterOptions: ",(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-tilemaps#FilteringOptions",children:"Phaser.Types.Tilemaps.FilteringOptions"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["The Filtering Options passed to ",(0,c.jsx)(s.code,{children:"GetTilesWithinWorldXY"})," as part of the ",(0,c.jsx)(s.code,{children:"collideSpriteVsTilemapLayer"})," check."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L403",children:"src/physics/arcade/World.js#L403"}),(0,c.jsx)(s.br,{}),"\nSince: 3.60.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"timescale",children:"timeScale"}),"\n",(0,c.jsx)(s.h3,{id:"timescale-number",children:"timeScale: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Scaling factor applied to the frame rate."}),"\n",(0,c.jsxs)(s.ul,{children:["\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:"1.0 = normal speed"}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:"2.0 = half speed"}),"\n"]}),"\n",(0,c.jsxs)(s.li,{children:["\n",(0,c.jsx)(s.p,{children:"0.5 = double speed"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L212",children:"src/physics/arcade/World.js#L212"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"tree",children:"tree"}),"\n",(0,c.jsxs)(s.h3,{id:"tree-phaserstructsrtree",children:["tree: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/structs-rtree",children:"Phaser.Structs.RTree"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The spatial index of Dynamic Bodies."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L356",children:"src/physics/arcade/World.js#L356"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"treeminmax",children:"treeMinMax"}),"\n",(0,c.jsxs)(s.h3,{id:"treeminmax-phasertypesphysicsarcadearcadeworldtreeminmax",children:["treeMinMax: ",(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeWorldTreeMinMax",children:"Phaser.Types.Physics.Arcade.ArcadeWorldTreeMinMax"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Recycled input for tree searches."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L374",children:"src/physics/arcade/World.js#L374"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"usetree",children:"useTree"}),"\n",(0,c.jsx)(s.h3,{id:"usetree-boolean",children:"useTree: boolean"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Should this Arcade Physics World use an RTree for Dynamic bodies?"}),"\n",(0,c.jsx)(s.p,{children:"An RTree is a fast way of spatially sorting of all the bodies in the world."}),"\n",(0,c.jsx)(s.p,{children:"However, at certain limits, the cost of clearing and inserting the bodies into the"}),"\n",(0,c.jsx)(s.p,{children:"tree every frame becomes more expensive than the search speed gains it provides."}),"\n",(0,c.jsx)(s.p,{children:"If you have a large number of dynamic bodies in your world then it may be best to"}),"\n",(0,c.jsxs)(s.p,{children:["disable the use of the RTree by setting this property to ",(0,c.jsx)(s.code,{children:"false"})," in the physics config."]}),"\n",(0,c.jsx)(s.p,{children:"The number it can cope with depends on browser and device, but a conservative estimate"}),"\n",(0,c.jsx)(s.p,{children:"of around 5,000 bodies should be considered the max before disabling it."}),"\n",(0,c.jsx)(s.p,{children:"This only applies to dynamic bodies. Static bodies are always kept in an RTree,"}),"\n",(0,c.jsx)(s.p,{children:"because they don't have to be cleared every frame, so you benefit from the"}),"\n",(0,c.jsx)(s.p,{children:"massive search speeds all the time."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L332",children:"src/physics/arcade/World.js#L332"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h1,{id:"private-members",children:"Private Members"}),"\n",(0,c.jsx)(s.h2,{id:"_category",children:"_category"}),"\n",(0,c.jsx)(s.h3,{id:"_category-number",children:"_category: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Holds the internal collision filter category."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/ArcadePhysics.js#L91",children:"src/physics/arcade/ArcadePhysics.js#L91"}),(0,c.jsx)(s.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_elapsed",children:"_elapsed"}),"\n",(0,c.jsx)(s.h3,{id:"_elapsed-number",children:"_elapsed: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"The amount of elapsed ms since the last frame."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L172",children:"src/physics/arcade/World.js#L172"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_frametime",children:"_frameTime"}),"\n",(0,c.jsx)(s.h3,{id:"_frametime-number",children:"_frameTime: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal frame time value."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L182",children:"src/physics/arcade/World.js#L182"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_frametimems",children:"_frameTimeMS"}),"\n",(0,c.jsx)(s.h3,{id:"_frametimems-number",children:"_frameTimeMS: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal frame time ms value."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L192",children:"src/physics/arcade/World.js#L192"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_tempmatrix",children:"_tempMatrix"}),"\n",(0,c.jsxs)(s.h3,{id:"_tempmatrix-phasergameobjectscomponentstransformmatrix",children:["_tempMatrix: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-components-transformmatrix",children:"Phaser.GameObjects.Components.TransformMatrix"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"A temporary Transform Matrix used by bodies for calculations without them needing their own local copy."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L383",children:"src/physics/arcade/World.js#L383"}),(0,c.jsx)(s.br,{}),"\nSince: 3.12.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_tempmatrix2",children:"_tempMatrix2"}),"\n",(0,c.jsxs)(s.h3,{id:"_tempmatrix2-phasergameobjectscomponentstransformmatrix",children:["_tempMatrix2: ",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-components-transformmatrix",children:"Phaser.GameObjects.Components.TransformMatrix"})]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"A temporary Transform Matrix used by bodies for calculations without them needing their own local copy."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L393",children:"src/physics/arcade/World.js#L393"}),(0,c.jsx)(s.br,{}),"\nSince: 3.12.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"_total",children:"_total"}),"\n",(0,c.jsx)(s.h3,{id:"_total-number",children:"_total: number"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Temporary total of colliding Bodies."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L272",children:"src/physics/arcade/World.js#L272"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h1,{id:"public-methods",children:"Public Methods"}),"\n",(0,c.jsx)(s.h2,{id:"add",children:"add"}),"\n",(0,c.jsx)(s.h3,{id:"instance-addbody",children:"<instance> add(body)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Adds an existing Arcade Physics Body or StaticBody to the simulation."}),"\n",(0,c.jsx)(s.p,{children:"The body is enabled and added to the local search trees."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsxs)(s.td,{children:[(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})," | ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"})]}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Body to be added to the simulation."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"}),", ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"})," - The Body that was added to the simulation."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L540",children:"src/physics/arcade/World.js#L540"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"addcollider",children:"addCollider"}),"\n",(0,c.jsx)(s.h3,{id:"instance-addcolliderobject1-object2-collidecallback-processcallback-callbackcontext",children:"<instance> addCollider(object1, object2, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Creates a new Collider object and adds it to the simulation."}),"\n",(0,c.jsx)(s.p,{children:"A Collider is a way to automatically perform collision checks between two objects,"}),"\n",(0,c.jsx)(s.p,{children:"calling the collide and process callbacks if they occur."}),"\n",(0,c.jsx)(s.p,{children:"Colliders are run as part of the World update, after all of the Bodies have updated."}),"\n",(0,c.jsxs)(s.p,{children:["By creating a Collider you don't need then call ",(0,c.jsx)(s.code,{children:"World.collide"})," in your ",(0,c.jsx)(s.code,{children:"update"})," loop,"]}),"\n",(0,c.jsx)(s.p,{children:"as it will be handled for you automatically."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide. Must return a boolean."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The scope in which to call the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-collider",children:"Phaser.Physics.Arcade.Collider"})," - The Collider that was created."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L801",children:"src/physics/arcade/World.js#L801"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"addlistener",children:"addListener"}),"\n",(0,c.jsx)(s.h3,{id:"instance-addlistenerevent-fn-context",children:"<instance> addListener(event, fn, [context])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Add a listener for a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"fn"}),(0,c.jsx)(s.td,{children:"function"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The listener function."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"context"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:'"this"'}),(0,c.jsx)(s.td,{children:"The context to invoke the listener with."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#addListener",children:"Phaser.Events.EventEmitter#addListener"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L111",children:"src/events/EventEmitter.js#L111"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"addoverlap",children:"addOverlap"}),"\n",(0,c.jsx)(s.h3,{id:"instance-addoverlapobject1-object2-collidecallback-processcallback-callbackcontext",children:"<instance> addOverlap(object1, object2, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Creates a new Overlap Collider object and adds it to the simulation."}),"\n",(0,c.jsx)(s.p,{children:"A Collider is a way to automatically perform overlap checks between two objects,"}),"\n",(0,c.jsx)(s.p,{children:"calling the collide and process callbacks if they occur."}),"\n",(0,c.jsx)(s.p,{children:"Colliders are run as part of the World update, after all of the Bodies have updated."}),"\n",(0,c.jsxs)(s.p,{children:["By creating a Collider you don't need then call ",(0,c.jsx)(s.code,{children:"World.overlap"})," in your ",(0,c.jsx)(s.code,{children:"update"})," loop,"]}),"\n",(0,c.jsx)(s.p,{children:"as it will be handled for you automatically."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for overlap."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for overlap."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects overlap."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects overlap. Must return a boolean."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The scope in which to call the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-collider",children:"Phaser.Physics.Arcade.Collider"})," - The Collider that was created."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L837",children:"src/physics/arcade/World.js#L837"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"cancollide",children:"canCollide"}),"\n",(0,c.jsx)(s.h3,{id:"instance-cancollidebody1-body2",children:"<instance> canCollide(body1, body2)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Checks if the two given Arcade Physics bodies will collide, or not,"}),"\n",(0,c.jsx)(s.p,{children:"based on their collision mask and collision categories."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeCollider",children:"Phaser.Types.Physics.Arcade.ArcadeCollider"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first body to check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeCollider",children:"Phaser.Types.Physics.Arcade.ArcadeCollider"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second body to check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if the two bodies will collide, otherwise false."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1993",children:"src/physics/arcade/World.js#L1993"}),(0,c.jsx)(s.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"circlebodyintersects",children:"circleBodyIntersects"}),"\n",(0,c.jsx)(s.h3,{id:"instance-circlebodyintersectscircle-body",children:"<instance> circleBodyIntersects(circle, body)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Tests if a circular Body intersects with another Body."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"circle"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The circular body to test."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The rectangular body to test."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if the two bodies intersect, otherwise false."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1731",children:"src/physics/arcade/World.js#L1731"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collide",children:"collide"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collideobject1-object2-collidecallback-processcallback-callbackcontext",children:"<instance> collide(object1, [object2], [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Performs a collision check and separation between the two physics enabled objects given, which can be single"}),"\n",(0,c.jsx)(s.p,{children:"Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups."}),"\n",(0,c.jsxs)(s.p,{children:["If you don't require separation then use ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#overlap",children:"Phaser.Physics.Arcade.World#overlap"})," instead."]}),"\n",(0,c.jsx)(s.p,{children:"If two Groups or arrays are passed, each member of one will be tested against each member of the other."}),"\n",(0,c.jsxs)(s.p,{children:["If ",(0,c.jsx)(s.strong,{children:"only"})," one Group is passed (as ",(0,c.jsx)(s.code,{children:"object1"}),"), each member of the Group will be collided against the other members."]}),"\n",(0,c.jsxs)(s.p,{children:["If ",(0,c.jsx)(s.strong,{children:"only"})," one Array is passed, the array is iterated and every element in it is tested against the others."]}),"\n",(0,c.jsx)(s.p,{children:"Two callbacks can be provided; they receive the colliding game objects as arguments."}),"\n",(0,c.jsxs)(s.p,{children:["If an overlap is detected, the ",(0,c.jsx)(s.code,{children:"processCallback"})," is called first. It can cancel the collision by returning false."]}),"\n",(0,c.jsxs)(s.p,{children:["Next the objects are separated and ",(0,c.jsx)(s.code,{children:"collideCallback"})," is invoked."]}),"\n",(0,c.jsx)(s.p,{children:"Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable"}),"\n",(0,c.jsx)(s.p,{children:"for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other."}),"\n",(0,c.jsx)(s.p,{children:"The separation that stops two objects penetrating may create a new penetration against a different object. If you"}),"\n",(0,c.jsx)(s.p,{children:"require a high level of stability please consider using an alternative physics system, such as Matter.js."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object or array of objects to check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["The second object or array of objects to check, or ",(0,c.jsx)(s.code,{children:"undefined"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - ",(0,c.jsx)(s.code,{children:"true"})," if any overlapping Game Objects were separated, otherwise ",(0,c.jsx)(s.code,{children:"false"}),"."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1780",children:"src/physics/arcade/World.js#L1780"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidespritevstilemaplayer",children:"collideSpriteVsTilemapLayer"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidespritevstilemaplayersprite-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideSpriteVsTilemapLayer(sprite, tilemapLayer, [collideCallback], [processCallback], [callbackContext], [overlapOnly])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal handler for Sprite vs. Tilemap collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"tilemapLayer"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tilemaplayer",children:"Phaser.Tilemaps.TilemapLayer"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_COLLIDE",children:"Phaser.Physics.Arcade.Events#event:TILE_COLLIDE"}),", ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_OVERLAP",children:"Phaser.Physics.Arcade.Events#event:TILE_OVERLAP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2273",children:"src/physics/arcade/World.js#L2273"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidetiles",children:"collideTiles"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidetilessprite-tiles-collidecallback-processcallback-callbackcontext",children:"<instance> collideTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects."}),"\n",(0,c.jsxs)(s.p,{children:["You should generally use the ",(0,c.jsx)(s.code,{children:"collide"})," method instead, with a Sprite vs. a Tilemap Layer, as that will perform"]}),"\n",(0,c.jsx)(s.p,{children:"tile filtering and culling for you, as well as handle the interesting face collision automatically."}),"\n",(0,c.jsx)(s.p,{children:"This method is offered for those who would like to check for collision with specific Tiles in a layer, without"}),"\n",(0,c.jsx)(s.p,{children:"having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions"}),"\n",(0,c.jsx)(s.p,{children:"on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,"}),"\n",(0,c.jsx)(s.p,{children:"you should filter them before passing them to this method."}),"\n",(0,c.jsxs)(s.p,{children:["Important: Use of this method skips the ",(0,c.jsx)(s.code,{children:"interesting faces"})," system that Tilemap Layers use. This means if you have"]}),"\n",(0,c.jsx)(s.p,{children:"say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the"}),"\n",(0,c.jsx)(s.p,{children:"tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on"}),"\n",(0,c.jsx)(s.p,{children:"dynamic maps, this method can prove very useful."}),"\n",(0,c.jsx)(s.p,{children:"This method does not factor in the Collision Mask or Category."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"tiles"}),(0,c.jsxs)(s.td,{children:["Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"}),">"]}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"An array of Tiles to check for collision against."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_COLLIDE",children:"Phaser.Physics.Arcade.Events#event:TILE_COLLIDE"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2194",children:"src/physics/arcade/World.js#L2194"}),(0,c.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"computeangularvelocity",children:"computeAngularVelocity"}),"\n",(0,c.jsx)(s.h3,{id:"instance-computeangularvelocitybody-delta",children:"<instance> computeAngularVelocity(body, delta)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Calculates a Body's angular velocity."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Body to compute the velocity for."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"delta"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The delta value to be used in the calculation, in seconds."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1191",children:"src/physics/arcade/World.js#L1191"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"computevelocity",children:"computeVelocity"}),"\n",(0,c.jsx)(s.h3,{id:"instance-computevelocitybody-delta",children:"<instance> computeVelocity(body, delta)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Calculates a Body's per-axis velocity."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Body to compute the velocity for."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"delta"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The delta value to be used in the calculation, in seconds."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1237",children:"src/physics/arcade/World.js#L1237"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"createdebuggraphic",children:"createDebugGraphic"}),"\n",(0,c.jsx)(s.h3,{id:"instance-createdebuggraphic",children:"<instance> createDebugGraphic()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Creates a Graphics Game Object that the world will use to render the debug display to."}),"\n",(0,c.jsxs)(s.p,{children:["This is called automatically when the World is instantiated if the ",(0,c.jsx)(s.code,{children:"debug"})," config property"]}),"\n",(0,c.jsxs)(s.p,{children:["was set to ",(0,c.jsx)(s.code,{children:"true"}),". However, you can call it at any point should you need to display the"]}),"\n",(0,c.jsx)(s.p,{children:"debug Graphic from a fixed point."}),"\n",(0,c.jsx)(s.p,{children:"You can control which objects are drawn to the Graphics object, and the colors they use,"}),"\n",(0,c.jsx)(s.p,{children:"by setting the debug properties in the physics config."}),"\n",(0,c.jsx)(s.p,{children:"You should not typically use this in a production game. Use it to aid during debugging."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-graphics",children:"Phaser.GameObjects.Graphics"})," - The Graphics object that was created for use by the World."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L668",children:"src/physics/arcade/World.js#L668"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"destroy",children:"destroy"}),"\n",(0,c.jsx)(s.h3,{id:"instance-destroy",children:"<instance> destroy()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Shuts down the simulation and disconnects it from the current scene."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Overrides:"})," Phaser.Events.EventEmitter#destroy"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2510",children:"src/physics/arcade/World.js#L2510"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"disable",children:"disable"}),"\n",(0,c.jsx)(s.h3,{id:"instance-disableobject",children:"<instance> disable(object)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Disables the Arcade Physics Body of a Game Object, an array of Game Objects, or the children of a Group."}),"\n",(0,c.jsxs)(s.p,{children:["The difference between this and the ",(0,c.jsx)(s.code,{children:"disableBody"})," method is that you can pass arrays or Groups"]}),"\n",(0,c.jsx)(s.p,{children:"to this method."}),"\n",(0,c.jsxs)(s.p,{children:["The body itself is not deleted, it just has its ",(0,c.jsx)(s.code,{children:"enable"})," property set to false, which"]}),"\n",(0,c.jsxs)(s.p,{children:["means you can re-enable it again at any point by passing it to enable ",(0,c.jsx)(s.code,{children:"World.enable"})," or ",(0,c.jsx)(s.code,{children:"World.add"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object"}),(0,c.jsxs)(s.td,{children:[(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})," | Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"}),">"]}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsxs)(s.td,{children:["Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"}),">"]})]})})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L570",children:"src/physics/arcade/World.js#L570"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"disablebody",children:"disableBody"}),"\n",(0,c.jsx)(s.h3,{id:"instance-disablebodybody",children:"<instance> disableBody(body)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Disables an existing Arcade Physics Body or StaticBody and removes it from the simulation."}),"\n",(0,c.jsx)(s.p,{children:"The body is disabled and removed from the local search trees."}),"\n",(0,c.jsxs)(s.p,{children:["The body itself is not deleted, it just has its ",(0,c.jsx)(s.code,{children:"enable"})," property set to false, which"]}),"\n",(0,c.jsxs)(s.p,{children:["means you can re-enable it again at any point by passing it to enable ",(0,c.jsx)(s.code,{children:"World.enable"})," or ",(0,c.jsx)(s.code,{children:"World.add"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsxs)(s.td,{children:[(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})," | ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"})]}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Body to be disabled."})]})})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L621",children:"src/physics/arcade/World.js#L621"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"emit",children:"emit"}),"\n",(0,c.jsx)(s.h3,{id:"instance-emitevent-args",children:"<instance> emit(event, [args])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Calls each of the listeners registered for a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"args"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Additional arguments that will be passed to the event handler."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - ",(0,c.jsx)(s.code,{children:"true"})," if the event had listeners, else ",(0,c.jsx)(s.code,{children:"false"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#emit",children:"Phaser.Events.EventEmitter#emit"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L86",children:"src/events/EventEmitter.js#L86"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"enable",children:"enable"}),"\n",(0,c.jsx)(s.h3,{id:"instance-enableobject-bodytype",children:"<instance> enable(object, [bodyType])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Adds an Arcade Physics Body to a Game Object, an array of Game Objects, or the children of a Group."}),"\n",(0,c.jsxs)(s.p,{children:["The difference between this and the ",(0,c.jsx)(s.code,{children:"enableBody"})," method is that you can pass arrays or Groups"]}),"\n",(0,c.jsx)(s.p,{children:"to this method."}),"\n",(0,c.jsx)(s.p,{children:"You can specify if the bodies are to be Dynamic or Static. A dynamic body can move via velocity and"}),"\n",(0,c.jsx)(s.p,{children:"acceleration. A static body remains fixed in place and as such is able to use an optimized search"}),"\n",(0,c.jsx)(s.p,{children:"tree, making it ideal for static elements such as level objects. You can still collide and overlap"}),"\n",(0,c.jsx)(s.p,{children:"with static bodies."}),"\n",(0,c.jsx)(s.p,{children:"Normally, rather than calling this method directly, you'd use the helper methods available in the"}),"\n",(0,c.jsx)(s.p,{children:"Arcade Physics Factory, such as:"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{className:"language-javascript",children:"\nthis.physics.add.image(x, y, textureKey);\n\nthis.physics.add.sprite(x, y, textureKey);\n\n"})}),"\n",(0,c.jsx)(s.p,{children:"Calling factory methods encapsulates the creation of a Game Object and the creation of its"}),"\n",(0,c.jsx)(s.p,{children:"body at the same time. If you are creating custom classes then you can pass them to this"}),"\n",(0,c.jsx)(s.p,{children:"method to have their bodies created."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object"}),(0,c.jsxs)(s.td,{children:[(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})," | Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"}),">"]}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsxs)(s.td,{children:["Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"}),">"]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"bodyType"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["The type of Body to create. Either ",(0,c.jsx)(s.code,{children:"DYNAMIC_BODY"})," or ",(0,c.jsx)(s.code,{children:"STATIC_BODY"}),"."]})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L418",children:"src/physics/arcade/World.js#L418"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"enablebody",children:"enableBody"}),"\n",(0,c.jsx)(s.h3,{id:"instance-enablebodyobject-bodytype",children:"<instance> enableBody(object, [bodyType])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Creates an Arcade Physics Body on a single Game Object."}),"\n",(0,c.jsx)(s.p,{children:"If the Game Object already has a body, this method will simply add it back into the simulation."}),"\n",(0,c.jsx)(s.p,{children:"You can specify if the body is Dynamic or Static. A dynamic body can move via velocity and"}),"\n",(0,c.jsx)(s.p,{children:"acceleration. A static body remains fixed in place and as such is able to use an optimized search"}),"\n",(0,c.jsx)(s.p,{children:"tree, making it ideal for static elements such as level objects. You can still collide and overlap"}),"\n",(0,c.jsx)(s.p,{children:"with static bodies."}),"\n",(0,c.jsx)(s.p,{children:"Normally, rather than calling this method directly, you'd use the helper methods available in the"}),"\n",(0,c.jsx)(s.p,{children:"Arcade Physics Factory, such as:"}),"\n",(0,c.jsx)(s.pre,{children:(0,c.jsx)(s.code,{className:"language-javascript",children:"\nthis.physics.add.image(x, y, textureKey);\n\nthis.physics.add.sprite(x, y, textureKey);\n\n"})}),"\n",(0,c.jsx)(s.p,{children:"Calling factory methods encapsulates the creation of a Game Object and the creation of its"}),"\n",(0,c.jsx)(s.p,{children:"body at the same time. If you are creating custom classes then you can pass them to this"}),"\n",(0,c.jsx)(s.p,{children:"method to have their bodies created."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Game Object on which to create the body."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"bodyType"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["The type of Body to create. Either ",(0,c.jsx)(s.code,{children:"DYNAMIC_BODY"})," or ",(0,c.jsx)(s.code,{children:"STATIC_BODY"}),"."]})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})," - The Game Object on which the body was created."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L486",children:"src/physics/arcade/World.js#L486"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"eventnames",children:"eventNames"}),"\n",(0,c.jsx)(s.h3,{id:"instance-eventnames",children:"<instance> eventNames()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Return an array listing the events for which the emitter has registered listeners."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," Array.<(string | symbol)> - undefined"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#eventNames",children:"Phaser.Events.EventEmitter#eventNames"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L55",children:"src/events/EventEmitter.js#L55"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"intersects",children:"intersects"}),"\n",(0,c.jsx)(s.h3,{id:"instance-intersectsbody1-body2",children:"<instance> intersects(body1, body2)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Checks to see if two Bodies intersect at all."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first body to check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second body to check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if the two bodies intersect, otherwise false."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1683",children:"src/physics/arcade/World.js#L1683"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"listenercount",children:"listenerCount"}),"\n",(0,c.jsx)(s.h3,{id:"instance-listenercountevent",children:"<instance> listenerCount(event)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Return the number of listeners listening to a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The event name."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," number - The number of listeners."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#listenerCount",children:"Phaser.Events.EventEmitter#listenerCount"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L75",children:"src/events/EventEmitter.js#L75"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"listeners",children:"listeners"}),"\n",(0,c.jsx)(s.h3,{id:"instance-listenersevent",children:"<instance> listeners(event)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Return the listeners registered for a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The event name."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," Array.<function()> - The registered listeners."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#listeners",children:"Phaser.Events.EventEmitter#listeners"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L64",children:"src/events/EventEmitter.js#L64"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"off",children:"off"}),"\n",(0,c.jsx)(s.h3,{id:"instance-offevent-fn-context-once",children:"<instance> off(event, [fn], [context], [once])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Remove the listeners of a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"fn"}),(0,c.jsx)(s.td,{children:"function"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove the listeners that match this function."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"context"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove the listeners that have this context."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"once"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove one-time listeners."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#off",children:"Phaser.Events.EventEmitter#off"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L151",children:"src/events/EventEmitter.js#L151"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"on",children:"on"}),"\n",(0,c.jsx)(s.h3,{id:"instance-onevent-fn-context",children:"<instance> on(event, fn, [context])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Add a listener for a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"fn"}),(0,c.jsx)(s.td,{children:"function"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The listener function."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"context"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:'"this"'}),(0,c.jsx)(s.td,{children:"The context to invoke the listener with."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#on",children:"Phaser.Events.EventEmitter#on"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L98",children:"src/events/EventEmitter.js#L98"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"once",children:"once"}),"\n",(0,c.jsx)(s.h3,{id:"instance-onceevent-fn-context",children:"<instance> once(event, fn, [context])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Add a one-time listener for a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"fn"}),(0,c.jsx)(s.td,{children:"function"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"The listener function."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"context"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:'"this"'}),(0,c.jsx)(s.td,{children:"The context to invoke the listener with."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#once",children:"Phaser.Events.EventEmitter#once"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L124",children:"src/events/EventEmitter.js#L124"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"overlap",children:"overlap"}),"\n",(0,c.jsx)(s.h3,{id:"instance-overlapobject1-object2-overlapcallback-processcallback-callbackcontext",children:"<instance> overlap(object1, [object2], [overlapCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Tests if Game Objects overlap."}),"\n",(0,c.jsxs)(s.p,{children:["See details in ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#collide",children:"Phaser.Physics.Arcade.World#collide"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object or array of objects to check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["The second object or array of objects to check, or ",(0,c.jsx)(s.code,{children:"undefined"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects overlap."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then ",(0,c.jsx)(s.code,{children:"overlapCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if at least one Game Object overlaps another."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1753",children:"src/physics/arcade/World.js#L1753"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"overlaptiles",children:"overlapTiles"}),"\n",(0,c.jsx)(s.h3,{id:"instance-overlaptilessprite-tiles-collidecallback-processcallback-callbackcontext",children:"<instance> overlapTiles(sprite, tiles, [collideCallback], [processCallback], [callbackContext])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects."}),"\n",(0,c.jsxs)(s.p,{children:["You should generally use the ",(0,c.jsx)(s.code,{children:"overlap"})," method instead, with a Sprite vs. a Tilemap Layer, as that will perform"]}),"\n",(0,c.jsx)(s.p,{children:"tile filtering and culling for you, as well as handle the interesting face collision automatically."}),"\n",(0,c.jsx)(s.p,{children:"This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without"}),"\n",(0,c.jsx)(s.p,{children:"having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap"}),"\n",(0,c.jsx)(s.p,{children:"tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,"}),"\n",(0,c.jsx)(s.p,{children:"you should filter them before passing them to this method."}),"\n",(0,c.jsx)(s.p,{children:"This method does not factor in the Collision Mask or Category."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"tiles"}),(0,c.jsxs)(s.td,{children:["Array.<",(0,c.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tile",children:"Phaser.Tilemaps.Tile"}),">"]}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"An array of Tiles to check for collision against."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects overlap."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_OVERLAP",children:"Phaser.Physics.Arcade.Events#event:TILE_OVERLAP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2236",children:"src/physics/arcade/World.js#L2236"}),(0,c.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"pause",children:"pause"}),"\n",(0,c.jsx)(s.h3,{id:"instance-pause",children:"<instance> pause()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Pauses the simulation."}),"\n",(0,c.jsx)(s.p,{children:"A paused simulation does not update any existing bodies, or run any Colliders."}),"\n",(0,c.jsx)(s.p,{children:"However, you can still enable and disable bodies within it, or manually run collide or overlap"}),"\n",(0,c.jsx)(s.p,{children:"checks."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#PAUSE",children:"Phaser.Physics.Arcade.Events#event:PAUSE"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L760",children:"src/physics/arcade/World.js#L760"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"postupdate",children:"postUpdate"}),"\n",(0,c.jsx)(s.h3,{id:"instance-postupdate",children:"<instance> postUpdate()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Updates bodies, draws the debug display, and handles pending queue operations."}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1077",children:"src/physics/arcade/World.js#L1077"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"remove",children:"remove"}),"\n",(0,c.jsx)(s.h3,{id:"instance-removebody",children:"<instance> remove(body)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Removes an existing Arcade Physics Body or StaticBody from the simulation."}),"\n",(0,c.jsx)(s.p,{children:"The body is disabled and removed from the local search trees."}),"\n",(0,c.jsxs)(s.p,{children:["The body itself is not deleted, it just has its ",(0,c.jsx)(s.code,{children:"enabled"})," property set to false, which"]}),"\n",(0,c.jsxs)(s.p,{children:["means you can re-enable it again at any point by passing it to enable ",(0,c.jsx)(s.code,{children:"enable"})," or ",(0,c.jsx)(s.code,{children:"add"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsxs)(s.td,{children:[(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})," | ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-staticbody",children:"Phaser.Physics.Arcade.StaticBody"})]}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The body to be removed from the simulation."})]})})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L641",children:"src/physics/arcade/World.js#L641"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"removealllisteners",children:"removeAllListeners"}),"\n",(0,c.jsx)(s.h3,{id:"instance-removealllistenersevent",children:"<instance> removeAllListeners([event])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Remove all listeners, or those of the specified event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The event name."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#removeAllListeners",children:"Phaser.Events.EventEmitter#removeAllListeners"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L165",children:"src/events/EventEmitter.js#L165"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"removecollider",children:"removeCollider"}),"\n",(0,c.jsx)(s.h3,{id:"instance-removecollidercollider",children:"<instance> removeCollider(collider)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Removes a Collider from the simulation so it is no longer processed."}),"\n",(0,c.jsx)(s.p,{children:"This method does not destroy the Collider. If you wish to add it back at a later stage you can call"}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"World.colliders.add(Collider)"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:["If you no longer need the Collider you can call the ",(0,c.jsx)(s.code,{children:"Collider.destroy"})," method instead, which will"]}),"\n",(0,c.jsx)(s.p,{children:"automatically clear all of its references and then remove it from the World. If you call destroy on"}),"\n",(0,c.jsxs)(s.p,{children:["a Collider you ",(0,c.jsx)(s.em,{children:"don't"})," need to pass it to this method too."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collider"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-collider",children:"Phaser.Physics.Arcade.Collider"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Collider to remove from the simulation."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L872",children:"src/physics/arcade/World.js#L872"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"removelistener",children:"removeListener"}),"\n",(0,c.jsx)(s.h3,{id:"instance-removelistenerevent-fn-context-once",children:"<instance> removeListener(event, [fn], [context], [once])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Remove the listeners of a given event."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"event"}),(0,c.jsx)(s.td,{children:"string | symbol"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The event name."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"fn"}),(0,c.jsx)(s.td,{children:"function"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove the listeners that match this function."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"context"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove the listeners that have this context."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"once"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Only remove one-time listeners."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - ",(0,c.jsx)(s.code,{children:"this"}),"."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Inherits:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/events-eventemitter#removeListener",children:"Phaser.Events.EventEmitter#removeListener"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/events/EventEmitter.js#L137",children:"src/events/EventEmitter.js#L137"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"resume",children:"resume"}),"\n",(0,c.jsx)(s.h3,{id:"instance-resume",children:"<instance> resume()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Resumes the simulation, if paused."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#RESUME",children:"Phaser.Physics.Arcade.Events#event:RESUME"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L783",children:"src/physics/arcade/World.js#L783"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"separate",children:"separate"}),"\n",(0,c.jsx)(s.h3,{id:"instance-separatebody1-body2-processcallback-callbackcontext-overlaponly",children:"<instance> separate(body1, body2, [processCallback], [callbackContext], [overlapOnly])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Separates two Bodies."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first Body to be separated."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second Body to be separated."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The process callback."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to invoke the callback."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"If this a collide or overlap check?"})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if separation occurred, otherwise false."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#COLLIDE",children:"Phaser.Physics.Arcade.Events#event:COLLIDE"}),", ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#OVERLAP",children:"Phaser.Physics.Arcade.Events#event:OVERLAP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1363",children:"src/physics/arcade/World.js#L1363"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"separatecircle",children:"separateCircle"}),"\n",(0,c.jsx)(s.h3,{id:"instance-separatecirclebody1-body2-overlaponly",children:"<instance> separateCircle(body1, body2, [overlapOnly])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Separates two Bodies, when both are circular."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first Body to be separated."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second Body to be separated."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"If this a collide or overlap check?"})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if separation occurred, otherwise false."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#COLLIDE",children:"Phaser.Physics.Arcade.Events#event:COLLIDE"}),", ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#OVERLAP",children:"Phaser.Physics.Arcade.Events#event:OVERLAP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1478",children:"src/physics/arcade/World.js#L1478"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"setbounds",children:"setBounds"}),"\n",(0,c.jsx)(s.h3,{id:"instance-setboundsx-y-width-height-checkleft-checkright-checkup-checkdown",children:"<instance> setBounds(x, y, width, height, [checkLeft], [checkRight], [checkUp], [checkDown])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Sets the position, size and properties of the World boundary."}),"\n",(0,c.jsx)(s.p,{children:"The World boundary is an invisible rectangle that defines the edges of the World."}),"\n",(0,c.jsx)(s.p,{children:"If a Body is set to collide with the world bounds then it will automatically stop"}),"\n",(0,c.jsx)(s.p,{children:"when it reaches any of the edges. You can optionally set which edges of the boundary"}),"\n",(0,c.jsx)(s.p,{children:"should be checked against."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"x"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The top-left x coordinate of the boundary."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"y"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The top-left y coordinate of the boundary."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"width"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The width of the boundary."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"height"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The height of the boundary."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"checkLeft"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Should bodies check against the left edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"checkRight"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Should bodies check against the right edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"checkUp"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Should bodies check against the top edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"checkDown"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Should bodies check against the bottom edge of the boundary?"})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L698",children:"src/physics/arcade/World.js#L698"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"setboundscollision",children:"setBoundsCollision"}),"\n",(0,c.jsx)(s.h3,{id:"instance-setboundscollisionleft-right-up-down",children:"<instance> setBoundsCollision([left], [right], [up], [down])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Enables or disables collisions on each edge of the World boundary."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"left"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"true"}),(0,c.jsx)(s.td,{children:"Should bodies check against the left edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"right"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"true"}),(0,c.jsx)(s.td,{children:"Should bodies check against the right edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"up"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"true"}),(0,c.jsx)(s.td,{children:"Should bodies check against the top edge of the boundary?"})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"down"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"true"}),(0,c.jsx)(s.td,{children:"Should bodies check against the bottom edge of the boundary?"})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L732",children:"src/physics/arcade/World.js#L732"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"setfps",children:"setFPS"}),"\n",(0,c.jsx)(s.h3,{id:"instance-setfpsframerate",children:"<instance> setFPS(framerate)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Sets the frame rate to run the simulation at."}),"\n",(0,c.jsx)(s.p,{children:"The frame rate value is used to simulate a fixed update time step. This fixed"}),"\n",(0,c.jsx)(s.p,{children:"time step allows for a straightforward implementation of a deterministic game state."}),"\n",(0,c.jsx)(s.p,{children:"This frame rate is independent of the frequency at which the game is rendering. The"}),"\n",(0,c.jsx)(s.p,{children:"higher you set the fps, the more physics simulation steps will occur per game step."}),"\n",(0,c.jsx)(s.p,{children:"Conversely, the lower you set it, the less will take place."}),"\n",(0,c.jsxs)(s.p,{children:["You can optionally advance the simulation directly yourself by calling the ",(0,c.jsx)(s.code,{children:"step"})," method."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"framerate"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The frame rate to advance the simulation at."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world",children:"Phaser.Physics.Arcade.World"})," - This World object."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L896",children:"src/physics/arcade/World.js#L896"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"shutdown",children:"shutdown"}),"\n",(0,c.jsx)(s.h3,{id:"instance-shutdown",children:"<instance> shutdown()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Shuts down the simulation, clearing physics data and removing listeners."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Overrides:"})," Phaser.Events.EventEmitter#shutdown"]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2493",children:"src/physics/arcade/World.js#L2493"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"singlestep",children:"singleStep"}),"\n",(0,c.jsx)(s.h3,{id:"instance-singlestep",children:"<instance> singleStep()"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Advances the simulation by a single step."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#WORLD_STEP",children:"Phaser.Physics.Arcade.Events#event:WORLD_STEP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1063",children:"src/physics/arcade/World.js#L1063"}),(0,c.jsx)(s.br,{}),"\nSince: 3.70.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"step",children:"step"}),"\n",(0,c.jsx)(s.h3,{id:"instance-stepdelta",children:"<instance> step(delta)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Advances the simulation by a time increment."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsx)(s.tbody,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"delta"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The delta time amount, in seconds, by which to advance the simulation."})]})})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#WORLD_STEP",children:"Phaser.Physics.Arcade.Events#event:WORLD_STEP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1011",children:"src/physics/arcade/World.js#L1011"}),(0,c.jsx)(s.br,{}),"\nSince: 3.10.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"update",children:"update"}),"\n",(0,c.jsx)(s.h3,{id:"instance-updatetime-delta",children:"<instance> update(time, delta)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Advances the simulation based on the elapsed time and fps rate."}),"\n",(0,c.jsx)(s.p,{children:"This is called automatically by your Scene and does not need to be invoked directly."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"time"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The current timestamp as generated by the Request Animation Frame or SetTimeout."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"delta"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The delta time, in ms, elapsed since the last frame."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#WORLD_STEP",children:"Phaser.Physics.Arcade.Events#event:WORLD_STEP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L924",children:"src/physics/arcade/World.js#L924"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"updatemotion",children:"updateMotion"}),"\n",(0,c.jsx)(s.h3,{id:"instance-updatemotionbody-delta",children:"<instance> updateMotion(body, delta)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Calculates a Body's velocity and updates its position."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"body"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-body",children:"Phaser.Physics.Arcade.Body"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The Body to be updated."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"delta"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The delta value to be used in the motion calculations, in seconds."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1172",children:"src/physics/arcade/World.js#L1172"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"wrap",children:"wrap"}),"\n",(0,c.jsx)(s.h3,{id:"instance-wrapobject-padding",children:"<instance> wrap(object, [padding])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["Wrap an object's coordinates (or several objects' coordinates) within ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#bounds",children:"Phaser.Physics.Arcade.World#bounds"}),"."]}),"\n",(0,c.jsx)(s.p,{children:"If the object is outside any boundary edge (left, top, right, bottom), it will be moved to the same offset from the opposite edge (the interior)."}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsxs)(s.td,{children:["A Game Object, a Group, an object with ",(0,c.jsx)(s.code,{children:"x"})," and ",(0,c.jsx)(s.code,{children:"y"})," coordinates, or an array of such objects."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"padding"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"0"}),(0,c.jsx)(s.td,{children:"An amount added to each boundary edge during the operation."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2428",children:"src/physics/arcade/World.js#L2428"}),(0,c.jsx)(s.br,{}),"\nSince: 3.3.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"wraparray",children:"wrapArray"}),"\n",(0,c.jsx)(s.h3,{id:"instance-wraparrayobjects-padding",children:"<instance> wrapArray(objects, [padding])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["Wrap each object's coordinates within ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#bounds",children:"Phaser.Physics.Arcade.World#bounds"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"objects"}),(0,c.jsx)(s.td,{children:"Array.<*>"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsx)(s.td,{children:"An array of objects to be wrapped."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"padding"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"0"}),(0,c.jsx)(s.td,{children:"An amount added to the boundary."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2459",children:"src/physics/arcade/World.js#L2459"}),(0,c.jsx)(s.br,{}),"\nSince: 3.3.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"wrapobject",children:"wrapObject"}),"\n",(0,c.jsx)(s.h3,{id:"instance-wrapobjectobject-padding",children:"<instance> wrapObject(object, [padding])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsxs)(s.p,{children:["Wrap an object's coordinates within ",(0,c.jsx)(s.a,{href:"/api-documentation/class/physics-arcade-world#bounds",children:"Phaser.Physics.Arcade.World#bounds"}),"."]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"default"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object"}),(0,c.jsx)(s.td,{children:"*"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{}),(0,c.jsxs)(s.td,{children:["A Game Object, a Physics Body, or any object with ",(0,c.jsx)(s.code,{children:"x"})," and ",(0,c.jsx)(s.code,{children:"y"})," coordinates"]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"padding"}),(0,c.jsx)(s.td,{children:"number"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"0"}),(0,c.jsx)(s.td,{children:"An amount added to the boundary."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2476",children:"src/physics/arcade/World.js#L2476"}),(0,c.jsx)(s.br,{}),"\nSince: 3.3.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h1,{id:"private-methods",children:"Private Methods"}),"\n",(0,c.jsx)(s.h2,{id:"collidegroupvsgroup",children:"collideGroupVsGroup"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidegroupvsgroupgroup1-group2-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideGroupVsGroup(group1, group2, [collideCallback], [processCallback], [callbackContext], overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal helper for Group vs. Group collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"group1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"group2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2396",children:"src/physics/arcade/World.js#L2396"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidegroupvstilemaplayer",children:"collideGroupVsTilemapLayer"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidegroupvstilemaplayergroup-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideGroupVsTilemapLayer(group, tilemapLayer, collideCallback, processCallback, callbackContext, overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal handler for Group vs. Tilemap collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"group"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"tilemapLayer"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tilemaplayer",children:"Phaser.Tilemaps.TilemapLayer"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2147",children:"src/physics/arcade/World.js#L2147"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidehandler",children:"collideHandler"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidehandlerobject1-object2-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideHandler(object1, object2, collideCallback, processCallback, callbackContext, overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal helper function. Please use Phaser.Physics.Arcade.World#collide and Phaser.Physics.Arcade.World#overlap instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object or array of objects to check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsxs)(s.td,{children:["The second object or array of objects to check, or ",(0,c.jsx)(s.code,{children:"undefined"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1914",children:"src/physics/arcade/World.js#L1914"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collideobjects",children:"collideObjects"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collideobjectsobject1-object2-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideObjects(object1, [object2], collideCallback, processCallback, callbackContext, overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal helper function. Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"object2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadeColliderType",children:"Phaser.Types.Physics.Arcade.ArcadeColliderType"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide. Must return a boolean."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The scope in which to call the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L1821",children:"src/physics/arcade/World.js#L1821"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidespritevsgroup",children:"collideSpriteVsGroup"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidespritevsgroupsprite-group-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideSpriteVsGroup(sprite, group, collideCallback, processCallback, callbackContext, overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal handler for Sprite vs. Group collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"group"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-group",children:"Phaser.GameObjects.Group"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The callback to invoke when the two objects collide. Must return a boolean."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The scope in which to call the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2054",children:"src/physics/arcade/World.js#L2054"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidespritevssprite",children:"collideSpriteVsSprite"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidespritevsspritesprite1-sprite2-collidecallback-processcallback-callbackcontext-overlaponly",children:"<instance> collideSpriteVsSprite(sprite1, sprite2, [collideCallback], [processCallback], [callbackContext], overlapOnly)"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal handler for Sprite vs. Sprite collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite1"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite2"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2014",children:"src/physics/arcade/World.js#L2014"}),(0,c.jsx)(s.br,{}),"\nSince: 3.0.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{}),"\n",(0,c.jsx)(s.h2,{id:"collidespritevstileshandler",children:"collideSpriteVsTilesHandler"}),"\n",(0,c.jsx)(s.h3,{id:"instance-collidespritevstileshandlersprite-tilemaplayer-collidecallback-processcallback-callbackcontext-overlaponly-islayer",children:"<instance> collideSpriteVsTilesHandler(sprite, tilemapLayer, [collideCallback], [processCallback], [callbackContext], [overlapOnly], [isLayer])"}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Description:"})}),"\n",(0,c.jsx)(s.p,{children:"Internal handler for Sprite vs. Tilemap collisions."}),"\n",(0,c.jsx)(s.p,{children:"Please use Phaser.Physics.Arcade.World#collide instead."}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Access:"})," private"]}),"\n",(0,c.jsx)(s.p,{children:(0,c.jsx)(s.strong,{children:"Parameters:"})}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,c.jsxs)(s.table,{children:[(0,c.jsx)(s.thead,{children:(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.th,{children:"name"}),(0,c.jsx)(s.th,{children:"type"}),(0,c.jsx)(s.th,{children:"optional"}),(0,c.jsx)(s.th,{children:"description"})]})}),(0,c.jsxs)(s.tbody,{children:[(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"sprite"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/gameobjects-gameobject",children:"Phaser.GameObjects.GameObject"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The first object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"tilemapLayer"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/class/tilemaps-tilemaplayer",children:"Phaser.Tilemaps.TilemapLayer"})}),(0,c.jsx)(s.td,{children:"No"}),(0,c.jsx)(s.td,{children:"The second object to check for collision."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"collideCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"An optional callback function that is called if the objects collide."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"processCallback"}),(0,c.jsx)(s.td,{children:(0,c.jsx)(s.a,{href:"/api-documentation/typedef/types-physics-arcade#ArcadePhysicsCallback",children:"Phaser.Types.Physics.Arcade.ArcadePhysicsCallback"})}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsxs)(s.td,{children:["An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then ",(0,c.jsx)(s.code,{children:"collideCallback"})," will only be called if this callback returns ",(0,c.jsx)(s.code,{children:"true"}),"."]})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"callbackContext"}),(0,c.jsx)(s.td,{children:"any"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"The context in which to run the callbacks."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"overlapOnly"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Whether this is a collision or overlap check."})]}),(0,c.jsxs)(s.tr,{children:[(0,c.jsx)(s.td,{children:"isLayer"}),(0,c.jsx)(s.td,{children:"boolean"}),(0,c.jsx)(s.td,{children:"Yes"}),(0,c.jsx)(s.td,{children:"Is this check coming from a TilemapLayer or an array of tiles?"})]})]})]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Returns:"})," boolean - True if any objects overlap (with ",(0,c.jsx)(s.code,{children:"overlapOnly"}),"); or true if any overlapping objects were separated."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.strong,{children:"Fires:"})," ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_COLLIDE",children:"Phaser.Physics.Arcade.Events#event:TILE_COLLIDE"}),", ",(0,c.jsx)(s.a,{href:"/api-documentation/event/physics-arcade-events#TILE_OVERLAP",children:"Phaser.Physics.Arcade.Events#event:TILE_OVERLAP"})]}),"\n",(0,c.jsxs)(s.blockquote,{children:["\n",(0,c.jsxs)(s.p,{children:["Source: ",(0,c.jsx)(s.a,{href:"https://github.com/phaserjs/phaser/blob/v3.87.0/src/physics/arcade/World.js#L2324",children:"src/physics/arcade/World.js#L2324"}),(0,c.jsx)(s.br,{}),"\nSince: 3.17.0"]}),"\n"]}),"\n",(0,c.jsx)(s.hr,{})]})}function o(e={}){let{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(h,{...e})}):h(e)}},28453:function(e,s,n){n.d(s,{R:()=>l,x:()=>t});var r=n(96540);let c={},i=r.createContext(c);function l(e){let s=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function t(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:l(e.components),r.createElement(i.Provider,{value:s},e.children)}}}]);